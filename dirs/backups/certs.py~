# $Header: //prod/main/sam/phoebe/pki/certs.py#7 $
# Copyright (c) 2010 Cisco Systems, Inc.
# All rights reserved.
# Unauthorized redistribution prohibited.

"""
Module to manage certificate pairs
"""

__version__ = '$Revision: #7 $'

import certconfig
import coro
import datafile
import fips
import process
import os
import shared.ObjectReferences
import sslip2 as openssl
import time
import ui_checker
import sys

import coro_ssl

from aplib.translation import gettext_lazy as _

IPDATA = os.getenv('IPDATA')
FIPS_VAR = 'system.system.fips_mode'

################################################################################

def config_change (oldvars):
    """ Function that gets called when certificate configuration changes
    """
    if oldvars is not None and 'certpairs' not in oldvars:
        return
    certificate_manager.update(certconfig.certpairs)
    certificate_manager.filter_smime_encrypt_compatible_certs()

def init ():
    """ Function that gets called when hermes starts up
    """
    certconfig.subscribe_to_config_change(config_change)
    config_change(None)

class CertException (openssl.Error):
    """ Generic exception class related to certificate errors
    """
    pass

class InvalidPasswordException (CertException):
    """ Exception class when for invalid password
    """
    pass

class InvalidFormatException (CertException):
    """ Exception class when data format is invalid
    """
    pass

class NonFIPSCompliantException(CertException):
    """Exception class when certificate is non FIPS compliant."""
    pass

class pkey (openssl.pkey):
    """Class representing a public/private key
    """
    def __init__ (self, ob=None, password='', private=False):
        """Constructs a private/public key

        :Parameters:
            - `ob`: Data to initialize class with
            - `password`: Password of private key
            - `private`: True if data is private key
        :Exceptions:
            - `CertException`: If PEM does not conform to RFC1421
        """
        try:
            super(pkey, self).__init__(ob, password, private)
        except openssl.Error:
            raise CertException(_('Invalid key format'))

class x509 (openssl.x509):
    """Class representing a X509 certificate
    """
    # These values must be indentical in "openssl/objects.h"
    SN_commonName = 'CN'
    SN_countryName = 'C'
    SN_localityName = 'L'
    SN_stateOrProvinceName = 'ST'
    SN_organizationName = 'O'
    SN_organizationalUnitName = 'OU'

    SN_mapping = [
        (SN_commonName, _('Common Name'), ui_checker.filter_and(
            ui_checker.validate_commonname, ui_checker.not_blank)),
        (SN_organizationName, _('Organization'), ui_checker.filter_and(
            ui_checker.validate_organization, ui_checker.not_blank)),
        (SN_organizationalUnitName, _('Organizational Unit'), ui_checker.filter_and(
            ui_checker.validate_organization, ui_checker.not_blank)),
        (SN_localityName, _('Locality or City'), ui_checker.filter_and(
            ui_checker.validate_city, ui_checker.not_blank)),
        (SN_stateOrProvinceName, _('State or Province'), ui_checker.filter_and(
            ui_checker.validate_state, ui_checker.not_blank)),
        (SN_countryName, _('Country (2 letter code)'), ui_checker.filter_and(
            ui_checker.validate_country_code, ui_checker.not_blank))
    ]

    def __init__ (self, pem=None):
        """Constructs a X509 certificate
        :Parameters:
            - `pem`: PEM string conforming to RFC1421 to initialize
                    class with.  None for empty.
        :Exceptions:
            - `CertException`: If PEM does not conform to RFC1421
        """
        try:
            super(x509, self).__init__(pem)
        except openssl.Error:
            raise CertException(_('Invalid X.509 format'))
        self.__subjects = None
        self.__issuers = None

    def __convert_entries(self, entries):
        """Convert a dictionary of asn1_object:asn_string
        to a dictionary of str:str

        :Parameters:
            - `entries`: Dictionary to convert

        :Return:
            Converted dictionary
        """
        return dict([(k.sn(), v.to_UTF8()) for k, v in  entries.items()])

    def get_subjects(self):
        """Retrieve all the certificate subject

        :Return:
            Dictionary of all certificate subjects where
            the key is the short name of the subject field
            and value is the corresponding value in UTF8
        """
        if not self.__subjects:
            entries = self.get_subject_name().get_entries()
            self.__subjects = self.__convert_entries(entries)

        return self.__subjects

    def get_issuers(self):
        """Retrieve all the certificate issuers

        :Return:
            Dictionary of all certificate issuers where
            the key is the short name of the issuer field
            and value is the corresponding value in UTF8
        """
        if not self.__issuers:
            entries = self.get_issuer().get_entries()
            self.__issuers = self.__convert_entries(entries)

        return self.__issuers

    def get_subject_by_SN (self, sn):
        """Retrieves a subject field, by short name,
        from the certificate

        :Parameter:
            - `sn`: Short name of field to retrieve

        :Return:
            Field corresponding to short name
        """
        return self.get_subjects().get(sn, "")

    def get_issuer_by_SN (self, sn):
        """Retrieves a issuer field, by short name,
        from the certificate

        :Parameter:
            - `sn`: Short name of field to retrieve

        :Return:
            Field corresponding to short name
        """
        return self.get_issuers().get(sn, "")

    def cmp_current_time (self):
        """Compares the cerificate validity with the current time

        "Return:
            - `-1`: If certificate is not yet valid
            -  `0`: If certificate is active
            -  `1`: If certificate is expired
        """
        before = self.get_notBefore()
        if before.cmp_current_time() > 0:
            return -1
        after = self.get_notAfter()
        if after.cmp_current_time() < 0:
            return 1
        return 0

    def get_status_description (self, in_use=False):
        """Retrieve a description on the status of this certificate

        :Parameters:
            - `in_use`: True if certificate is in use.  False if not.

        "Return:
            String containing the status of this certificate
        """
        status = self.cmp_current_time()
        if not status and in_use:
            return _('Active')
        return {-1:_('Not Yet Valid'), 0:_('Valid'),
            1:_('Expired')}[status]

    def get_days_remaining (self):
        """Retrieve the number of days remaining before certificate expires

        :Return:
            Integer containing number of days before certificate expires
        """
        notafter = self.get_notAfter().to_string()
        try:
            after = time.strptime(notafter, "%b %d %H:%M:%S %Y %Z")
        except ValueError:
            raise CertException(_('Invalid time string format "%s"') % (notafter,))
        diff = time.mktime(after) - time.mktime(time.gmtime())
        return int(diff / 60 / 60 / 24)

def to_x509 (data):
    """ Converts te data to a x509 object

    :Parameters:
        - `data`: Object to convert

    :Return:
        Instance of class x509

    :Exceptions:
        - `CertException`: If unable to convert object
    """
    if isinstance(data, openssl.x509):
        data = data.as_pem()

    if isinstance(data, str):
        data = x509(data)

    if isinstance(data, x509) or data is None:
        return data

    raise CertException(_('Invalid X.509 certificate format %r') % (type(data),))

class x509list (list):
    """ Class representation of a list containing X.509
    """
    def __setitem__ (self, index, data):
        """ Sets an item in the list at the index location

        :Parameters:
            - `index`: Index location to add data
            - `data`: Item to add to list

        :Exceptions:
            - `CertException`: If data does not represent X.509
        """
        data = to_x509(data)
        if data is None:
            raise CertException(_('None not allowed in X.509 list'))
        super(x509list, self).__setitem__(index, data)

    def append (self, data):
        """ Appends an item to the list
        :Parameters:
            - `data`: Item to append to list
        :Exceptions:
            - `CertException`: If data does not represent X.509
        """
        data = to_x509(data)
        if data is None:
            raise CertException(_('None not allowed in X.509 list'))
        super(x509list, self).append(data)

class CertPair (object):
    """Class representing a private key, public certificate, and intermediate
    certificates
    """

    def __init__ (self, key=None, cert=None, intermediate=None):
        """Constructs a certificate pair

        :Parameters:
            - `key`: Private key in PEM format or instance of class pkey
            - `cert`: Public certificate in PEM format or instance of class x509
            - `intermediate`: List of intermediate certificates in
                    PEM format or instance of class x509

        :Exceptions:
            - `CertException`: If parameters are invalid format
        """
        self.__set_key(key)
        self.__set_cert(cert)
        self.__set_intermediate(intermediate)

    @staticmethod
    def create_smime_self_signed_cert_pair (subjects, subAltNameValue,
                                       days=365, size=2048):
        """Create a S/MIME self-signed certificate
        :Parameters:

            - `subjects`: Dictionary of the subject fields for the
                          self-signed certificate
            - `email`: Email address of the S/MIME gateway
            - `dns_list`: List of domains the certificate is used for
            - `days`: Number of days until certificate expires
            - `size`: Size of private key

        :Returns:
            Returns itself

        :Exceptions:
            - `CertException`: If unable to create self signed cert
        """
        if days <= 0:
            raise CertException(_('Number of days for certificate expiration '
                                  'must be greater than zero'))

        if size <= 0:
            raise CertException(_('Private key size must be greater than'
                                  ' zero'))
        if not subAltNameValue:
            raise CertException(_("'subjectAltName' value cannot be empty"))

        cert_pair = CertPair()
        # Create private key
        cert_pair.__key = pkey(openssl.rsa(size), private=True)

        # Create self signed certificate
        cert_pair.__cert = x509('')
        cert_pair.__cert.set_version(0x3)
        cert_pair.__cert.get_subject_name().add_entries_by_txt(subjects)
        # For self-signed, subject == issuer
        cert_pair.__cert.get_issuer().add_entries_by_txt(subjects)
        cert_pair.__cert.get_notBefore().set_now()
        cert_pair.__cert.get_notAfter().set_now()
        cert_pair.__cert.get_notAfter().gmtime_adj(60 * 60 * 24 * days)
        cert_pair.__cert.set_pubkey(cert_pair.__key)
        cert_pair.__cert.set_serialNumber()
        # Add neseccary S/MIME Extension
        cert_pair.__cert.add_subjectAltNameExt(subAltNameValue)
        cert_pair.__cert.add_keyUsageExt('critical,digitalSignature,'
                                         'nonRepudiation,keyEncipherment')
        cert_pair.__cert.add_extendedKeyUsageExt('critical,emailProtection')
        # Finally sign it
        cert_pair.__cert.sign(cert_pair.__key)

        return cert_pair

    def self_signed (self, subjects, days=365, size=2048):
        """Create a self-signed certificate
        :Parameters:

            - `subjects`: Dictionory of the subject fields for the
                          self-signed certificate
            - `days`: Number of days until certificate expires
            - `size`: Size of private key

        :Returns:
            Returns itself

        :Exceptions:
            - `CertException`: If unable to create self signed cert
        """
        if days <= 0:
            raise CertException(_('Number of days for certificate '
                'expiration must be greater than zero'))

        if size <= 0:
            raise CertException(
                _('Private key size must be greater than zero'))

        # Create private key
        self.__key = pkey(openssl.rsa(size), private=True)

        # Create self signed certificate
        self.__cert = x509('')
        self.__cert.set_version(0x3)
        self.__cert.get_subject_name().add_entries_by_txt(subjects)
        # For self-signed, subject == issuer
        self.__cert.get_issuer().add_entries_by_txt(subjects)
        self.__cert.get_notBefore().set_now()
        self.__cert.get_notAfter().set_now()
        self.__cert.get_notAfter().gmtime_adj(60 * 60 * 24 * days)
        self.__cert.set_pubkey(self.__key)
        self.__cert.set_serialNumber()
        self.__cert.sign(self.__key)

        return self

    def get_csr (self):
        """ Retrieves a certificate signing requested signed
        by the private key.

        :Return:
            x509_req object containing the CSR
        """
        csr = self.__cert.to_x509_req()
        try:
            csr.sign(self.__key)
        except openssl.Error:
            raise CertException(_('Could not verify the CSR and the key'))
        return csr

    def __get_key(self):
        """Retrieves the private key from the cert pair

        :Return:
            Instance of pkey containing the private key.
        """
        return self.__key

    def __set_key (self, data):
        """Sets the private key from the cert pair

        :Parameters:
            - `data`: Private key as a pkey instance or PEM

        :Exceptions:
            - `CertException`: If unable to convert PEM to pkey
        """
        if isinstance(data, openssl.pkey):
            data = data.get_private()

        if isinstance(data, str):
            data = pkey(data, private=True)

        if isinstance(data, pkey) or data is None:
            self.__key = data

        else:
            raise CertException(_('Invalid private key format %r') % (type(data),))

    key = property(__get_key, __set_key)

    def __get_cert(self):
        """Retrieves the public certificate from the cert pair

        :Return:
            Instance of x509 containing the public certificate.
        """
        return self.__cert

    def __set_cert (self, data):
        """Sets the public certificate from the cert pair

        :Parameters:
            - `data`: Instance of x509 containing the public certificate.
        """
        try:
            self.__cert = to_x509(data)
        except CertException:
            raise CertException(_('Invalid pulic certificate format %r') % (type(data),))

    cert = property(__get_cert, __set_cert)

    def __get_intermediate(self):
        """Retrieves the list of intermediate certificates from the cert pair

        :Return:
            List of x509 containing the intermdiate certificates.
        """
        return self.__chain

    def __set_intermediate (self, intermediate):
        """Sets the list of intermediate certificates from the cert pair

        :Parameters:
            - `intermediate`: List of intermediate certificates of type x509

        :Returns:
        """
        if intermediate is None:
            intermediate = []

        if not isinstance(intermediate, list):
            raise CertException(_('Intermediate must be a list of X.509'))

        chain = x509list()
        for cert in intermediate:
            if cert is None:
                raise CertException(_('Intermediate list can not contain None'))
            chain.append(cert)
        self.__chain = chain

    intermediate = property(__get_intermediate, __set_intermediate)

    def is_valid (self):
        """Determines if this certificate pair is valid or not
        by determining if the key can sign the certificate.

        :Return:
            True if valid.  False if invalid
        """
        if not self.__cert.check_private_key(self.__key):
            return False
        try:
            # ctx = openssl.ssl_ctx()
            ctx = coro_ssl.new_ssl_ctx()
            self.update_context(ctx)
            return ctx.check_key()
        except:
            return False

    def to_dict (self):
        """Returns the a dictionary of this class in PEM format

        :Return:
            Dictionary in PEM format
        """
        return {'key':self.__key.get_private(), 'cert':self.__cert.as_pem(),
            'intermediate':[ca.as_pem() for ca in self.__chain]}

    @staticmethod
    def from_dict (cert):
        """Creates a CertPair from a dictionary created by method to_dict

        :Parameter:
            - `cert`: Dictionary in PEM format
        """
        return CertPair(cert.get('key'), cert.get('cert'),
            cert.get('intermediate'))

    def copy (self):
        """Returns a deep copy of this object.

        :Return:
            An instance of CertPair containing a deep copy of this object.
        """
        return CertPair(self.__key.get_private(), self.__cert.as_pem(),
                        [ca.as_pem() for ca in self.__chain])

    def __str__ (self):
        """Returns a string representation of this class

        :Return:
            String representation of this class
        """
        return "CertPair%s" % (self.to_dict(),)

    @staticmethod
    def our_log(some_string):
        if not isinstance(some_string, str):
            some_string = str(some_string)
        with open('/data/tmp/our_log', 'a') as our_log:
            our_log.write(some_string)
            our_log.write("\n")

    def update_context(self, ctx):
        """ Updates the SSL context

        :Parameters:
            - `ctx`: SSL context to update
        """
        import traceback
        self.our_log("Tracebak:")
        for msgg in traceback.format_stack():
            self.our_log(str(msgg))

        if isinstance(ctx, openssl.ssl_ctx):
            ctx.use_cert(self.cert, tuple(self.intermediate))
            ctx.use_key(self.key)
            self.our_log("IS INSTANCE")
            self.our_log("Certificate")
            self.our_log(self.cert.get_subjects())
            self.our_log("Itermediate: ")
            self.our_log(tuple(self.intermediate))
        elif coro.coro_is_running():
            import sslip
            cert_obj = sslip.read_pem_cert(self.cert.as_pem())

            tls_chain = []
            for cert in self.intermediate:
                tls_chain.append(sslip.read_pem_cert(cert.as_pem()))
            ctx.use_cert(cert_obj, tuple(tls_chain))
            key_obj = sslip.read_pem_key(self.key.get_private(), '')
            ctx.use_key(key_obj)
            try:
                self.our_log("NOT INSTANCE")
                self.our_log("Certificate")
                self.our_log(cert_obj.get_subject())
                self.our_log("Itermediate: ")
                self.our_log(tls_chain)
            except:
                pass


class pkcs12 (openssl.pkcs12):
    """Class representing a PKCS#12 certificate
    """

    def __init__ (self, data=None):
        """Constructs a pkcs12

        :Parameter:
            - `data`: String containing binary PKCS#12 data

        :Exceptions:
            - `CertException`: If data is not PKCS#12
        """
        try:
            super(pkcs12, self).__init__(data)
        except openssl.Error:
            raise InvalidFormatException(_('Invalid PKCS#12 format'))

    def parse (self, password):
        """Parse the PKCS#12 with the password

        :Parameter:
            - `password`: Password to parse PKCS#12

        :Return:
            Tuple containing (pkey, x509, [x509...])

        :Exceptions:
            - `NonFIPSCompliantException`: If certificate is non FIPS-compliant
            - `CertException`: If password is invalid
        """
        try:
            return super(pkcs12, self).parse(password)
        except openssl.Error, (errno, errmsg):
            # Check for EVP_R_DISABLED_FOR_FIPS error.
            if errno == 101167248:
                raise NonFIPSCompliantException(
                    _('Certificate is non FIPS-compliant'))
            else:
                raise InvalidPasswordException(_('Invalid PKCS#12 password'))

    def decrypt (self, password):
        """Decrypts the content of the PKCS#12 certificate

        :Parameters:
            - `password`: Password of the PKCS#12 certificate

        :Return:
            Instance of a CertPair class
        """
        try:
            cp = CertPair()
            cp.key, cp.cert, cp.intermediate = self.parse(password)
            return cp
        except CertException:
            raise
        except openssl.Error, err:
            raise CertException(err)

    @staticmethod
    def encrypt (certpair, password, name=None):
        """Encrypts the certificate pair into a PKCS#12 certificate

        :Parameters:
            - `certpair`: Instance of CertPair class
            - `password`: Password to assign to the PKCS#12 certificate
            - `name`: Name to assign to the PKCS#12 certificate
        """
        p12 = pkcs12()
        try:
            p12.create(password, certpair.key, certpair.cert,
                certpair.intermediate, name)
        except openssl.Error, (errno, errmsg):
            if errno == 185073780:
                raise CertException(_('Unable to create PKCS#12 '
                    'certificate: Key values mismatch'))
            raise CertException(errno, errmsg)
        return p12

class CertMgr (object):
    """Class to manage certificate pairs
    """
    VARSTORE = 'hermes.pki.certpairs'

    def __init__ (self, varstore):
        """Constructs a CertMgr

        :Parameters:
            - `varstore`: Instance of the variable store
        """
        super(CertMgr, self).__init__()
        self.__certificates = {}
        if varstore:
            self.__varstore = None
            self.update(varstore.read_var(self.VARSTORE))
        self.__varstore = varstore
        self.smime_encrypt_compatible_certs = {}

    def __len__ (self):
        """Returns number of items store in the certificate manager

        :Return:
            Number of itmes stored in certificate manager
        """
        return len(self.__certificates)

    def update (self, cdict):
        """ Update and replace the certificate manager with a new
        dictionary

        :Parameters:
            - `cdict`: Dictionary to update certificate manager with

        :Exception:
            - `CertException`: If invalid certificate found in dictionary
        """
        self.__certificates.clear()
        for key, value in cdict.iteritems():
            self.__put(key, value)
        self.__submit()

    def __put (self, name, cert):
        """Add or replace a certificate pair

        :Parameters:
            - `name`: Name to assign CertPair
            - `cert`: Instance of certificate pair

        :Return:
            Certificate pair added

        :Exception:
            - `CertException`: If certificate is not valid
        """
        if isinstance(cert, dict):
            cert = CertPair.from_dict(cert)

        elif not isinstance(cert, CertPair):
            raise CertException(_('Invalid certificate pair type %r') % (type(cert),))

        if not cert.is_valid():
            raise CertException(_('The key does not sign certificate'))

        self.__certificates[name] = cert
        return cert

    def put (self, name, cert):
        """Add or replace a certificate pair and writes the
        changes to the varstore.

        :Parameters:
            - `name`: Name to assign CertPair
            - `cert`: Instance of certificate pair

        :Return:
            Certificate pair added

        :Exception:
            - `CertException`: If certificate is not valid
        """
        self.__put(name, cert)
        self.__submit()
        return cert

    def get (self, name, default=None):
        """Retrieves a certificate pair

        :Parameters:
            - `name`: Name of certificate to retrieve
            - `default`: Default to use if certifcate can not be found

        :Return:
            Reference to instance of class CertPair corresponding to the name.
            If certificate is not found, default is returned.
            Any modifications should be added back into the certificate
            so the varstore can be properly updated.
        """
        return self.__certificates.get(name, default)

    def remove (self, name):
        """Removes a certificate profile from the certificate manager
        and writes the changes to the varstore.

        :Parameters:
            - `name`: Name of certificate profile to remove

        :Exception:
            - `CertException`: If certificate is in use
        """
        try:
            del self.__certificates[name]
            self.__submit()
        except KeyError:
            raise CertException(_('Unable to remove certificate. '
                'Profile name "%s" does not exist.') % (name,))

    def in_use (self, name):
        """Checks to see if certificate is in use

        :Parameters:
            - `name`: Name of certificate to for usage

        :Return:
            String containing name of interface using certificate.
            None if certficate is not in use
        """
        if not self.__varstore:
            return None

        used_by = \
            shared.ObjectReferences.references_object(
                self.__varstore, shared.ObjectReferences.OBJTYPE_CERT, name)
        if not used_by or len(used_by) == 0:
            return None
        return [name for serial, refs, name in used_by]

    def __iter__ (self):
        """ Retrieves the current certificate pair in the iteration

        :Return:
            Iterator containing certificates stored by this manager.
        """
        self.__iterator = iter(sorted(self.__certificates.keys()))
        return self

    def next(self):
        """ Increment to the next certificate pair in the list.

        :Return:
           Tuple containing (certname, certpair) where
                - `certname`: Name of certificate profile
                - `certpair`: Instance of class CertPair
        """
        if self.__iterator:
            key = self.__iterator.next()
            return key, self.get(key)

        raise StopIteration

    def __submit (self):
        """ Save changes to the varstore
        """
        if self.__varstore:
            vardict = {}
            for key, value in self.__certificates.iteritems():
                vardict[key] = value.to_dict()
            self.__varstore.change_var(self.VARSTORE, vardict)

    def filter_smime_encrypt_compatible_certs(self):
        self.smime_encrypt_compatible_certs.clear()
        for name, certpair in self.__certificates.iteritems():
            try:
                ui_checker.validate_cert_smime_encrypt_compatible(
                                                   certpair.cert)
                self.smime_encrypt_compatible_certs[name] = certpair
            except ui_checker.FilterError:
                pass

    def __str__ (self):
        """Returns a string representation of this class

        :Return:
            String representation of this class
        """
        return "CertMgr%r" % (self.__certificates,)

################################################################################

status, stdout_data = process.capture(
                              '%s/bin/get_config_var %s' % (IPDATA, FIPS_VAR))
if stdout_data and stdout_data[0] == '1':
    cert_pem = datafile.get_file('coroutine/coro_ssl_data/demo-cert_2048.txt')
    key_pem = datafile.get_file('coroutine/coro_ssl_data/demo-key_2048.txt')
else:
    cert_pem = datafile.get_file('coroutine/coro_ssl_data/demo-cert_1024.txt')
    key_pem = datafile.get_file('coroutine/coro_ssl_data/demo-key_1024.txt')
key_pass = datafile.get_file('coroutine/coro_ssl_data/demo-pass.txt')

default_cert = CertPair()
default_cert.key = pkey(key_pem, key_pass, private=True)
default_cert.cert = cert_pem
default_cert_name = "Demo"
default_cert_display_name = _('System Default')
default_certid = ""

certificate_manager = CertMgr(None)
try:
    with open('/data/tmp/our_log', 'a') as our_log:
        our_log.write(str(func_name_caller.f_code.co_name))
except:
    pass

