# $Revision: #52 $
#
# LDAP API betwen hermes and the LDAP client
#
# Notable oddities:
#   - The way arguments are marshalled between instantiated meta-queries
#     and the generic meta-query logic is weird.
#   - A generic "query" class should be made to clean-up/clarify common
#     code.

import binascii
import certconfig
import crypt
import gettext
import sslip2
import operator
import re
import types
import string
import sys

import CommandManager
import coro
import coro_ssl
import ironutil
import ldap
import ldap_client
import network_manager
import qlog
import rfc_2821_parse
import rfc_2822_parse
import sslip

from aplib import tsc_time
from command_client import quick_read_var_auto_level
from Commandment import NOTSET

# Module Globals
################

_ = gettext.gettext

# LDAPS config variables
ssl_certid = None
ssl_ctx = None

enabled = 1

querylabels = {'ldapaccept':'rat',
               'ldaprouting':'reroute',
               'masquerade':'masquerade',
               'ldapgroup':'group',
               'smtpauth':'smtpauth',
               'certauth':'certauth',
               'externalauth':'externalauth',
               'isqauth': 'isqauth',
               'isqalias': 'primaryaddress',
               'ldapuserdn':'userdn',
            }

querylabels_reverse = dict((v,k) for k,v in querylabels.items())

querydefaults_ad = {
    'rat':'(proxyAddresses=smtp:{a})', # See bug 27817
    'reroute':'(mailLocalAddress={a})',
    'masquerade':'(mailRoutingAddress={a})',
    'group':'(&(memberOf={g})(proxyAddresses=smtp:{a}))', #bug27817
    'smtpauth':'(sAMAccountName={u})',
    'isqauth':'(sAMAccountName={u})',
    'certauth':'',
    'primaryaddress':
        '(|(proxyAddresses={a})(proxyAddresses=smtp:{a}))',
    'userdn':'(proxyAddresses=smtp:{a})',
}

querydefaults_openldap = {
    'rat':'(mail={a})',
    'reroute':'(mailLocalAddress={a})',
    'masquerade':'(mailRoutingAddress={a})',
    'group':'(&(objectClass=posixGroup)(cn={g})(memberUid={u}))',
    'smtpauth':'(uid={u})',
    'certauth':'',
    'isqauth':'(uid={u})',
    'primaryaddress':'(mail={a})',
    'userdn':'(mail={a})',
}

querydefaults_other = {
    'rat':            '',
    'reroute':        '',
    'masquerade':     '',
    'group':          '',
    'smtpauth':       '',
    'isqauth':        '',
    'certauth':       '',
    'primaryaddress': '',
    'userdn':      '',
}

querydefaults = {
    'ad': querydefaults_ad,
    'openldap': querydefaults_openldap,
    '': querydefaults_other,
}

portdefaults_withSSL = {
    'ad': 3269,
    'openldap': 636,
    '': 3269
}

portdefaults_withoutSSL = {
    'ad': 3268,
    'openldap': 389,
    '': 3268
}

certificate_subject_fields_map = {
    'dn': 0,
    'cn': sslip.NID_commonName,
    'o': sslip.NID_organizationName,
    'ou': sslip.NID_organizationalUnitName,
    'c': sslip.NID_countryName,
    'n': sslip.NID_name
}


def get_port_default(server_type, use_ssl=False):
    """
    Get default port for the given server_type based on the boolean 'use_ssl' value.
    """
    if use_ssl:
        try:
            return portdefaults_withSSL[server_type]
        except:
            return portdefaults_withSSL['']
    else:
        try:
            return portdefaults_withoutSSL[server_type]
        except:
            return portdefaults_withoutSSL['']


# email attribute defaults for 'isqauth' and 'primaryaddress'
email_attributes_defaults = {
'ad': {
    'isqauth': 'proxyAddresses',
    'primaryaddress': 'mail',
    },
'openldap': {
    'isqauth': 'mail',
    'primaryaddress': 'mail',
    },
'': {
    'isqauth': '',
    'primaryaddress': '',
    },
}


def get_email_attribute_defaults(server_type, query_type):
    """
    Get default email attribute for 'isqauth' and 'primaryaddress' based on server_type.
    """
    try:
        server_default = email_attributes_defaults[server_type]
    except KeyError:
        server_default = email_attributes_defaults['']
    return server_default.get(query_type,'')


def get_query_default(server_type, query_type):
    """
    Get default query base on server_type and query_type.

    If default for server_type is not defined, treat this leniently by returning
    the default of default query.

    If query_type is not defined, raise KeyError.
    """
    if server_type not in querydefaults:
        server_type = ''
    return querydefaults[server_type][query_type]

typevars = {'reroute': ['mailRoutingAddress', 'mailHost'],
            'rat': [],
            'masquerade': ['mailLocalAddress', 'mailLocalAddressFriendly'],
            'group': ['groupMembers'],
            'smtpauth': ['userPassword', 'query_allow'],
            'smtpauthbind': ['max_connections', 'query_allow'], # special case of smtpauth
            'certauth': ['auth_fields', 'uid'],
            'externalauth': [
                'account_base',
                'group_base',
                'gecos_attribute',
                'group_name_attribute',
                'member_attribute',
                'expire_attribute',
                'last_change_attribute',
                'last_change_max_attribute',],
            'isqauth': ['email_attributes'],
            'primaryaddress': ['email_attributes'],
            'userdn':[],
            }

# {'fieldname': (question, description), ...}
# if question is None, always ask for the value using description as the prompt
# if description is None, the question is a boolean
typevardescs = {
    'mailroutingaddress':(
        _('Rewrite the Envelope Recipient (and leave MAILHOST unconfigured)?'),
        _('Enter the attribute which contains the full rfc822 email address '
            'for the recipients.')),
    'mailhost':(
        _('Send the messages to an alternate mail host (and leave MAILROUTINGADDRESS unconfigured)?'),
        _('Enter the attribute which contains the alternate mailhost for '
            'the recipients.')),
    'maillocaladdress':(
        None,
        _('Enter the attribute which contains the externally visible full '
            'rfc822 email address.')),
    'maillocaladdressfriendly':(
        _('Do you want the results of the returned attribute to replace the '
            'entire friendly portion of the original recipient?'),
        None),
    'groupmembers':(
        None,
        _('Enter the group membership attribute.')),
    'userpassword':(
        None,
        _('Enter the attribute which contains the SMTP authentication '
            'password for a given user.')),
    'max_connections':(
        None,
        _('Please enter the number of concurrent connections to dedicate to '
            'this query.')),
    'domainmap':(
        None,
        _('Enter the domain map.')),
    'defaultdomain':(
        None,
        _('Enter the domain map default.')),
    'chainlist':(
        None,
        _('Enter the list of chained queries.')),
    'email_attributes':(
        None,
        _('Enter the email attribute.')),
    'account_base':(
        None,
        _('Under what base DN will user records be found?')),
    'group_base':(
        None,
        _('Under what base DN will group records be found?')),
    'gecos_attribute':(
        None,
        _('What attribute will contain the user\'s full name?')),
    'group_name_attribute':(
        None,
        _('What attribute in these records will contain the group name?')),
    'member_attribute':(
        None,
        _('What attribute in these records holds each member\'s username '
            '(or a DN for the user\'s record)?')),
    'expire_attribute':(
        None,
        _('What attribute (if any) holds the account expiration date?  This '
            'must comply with RFC 2307.')),
    'last_change_attribute':(
        None,
        _('What attribute (if any) holds the time the user\'s password was '
            'last changed?  This must comply with RFC 2307.')),
    'last_change_max_attribute':(
        None,
        _('What attribute (if any) holds the maximum password age?  This must '
            'comply with RFC 2307.')),
    'query_allow':(
        None,
        _('Enter the LDAP query string to check if SMTP AUTH allowed '
          '(optional).')),
    'auth_fields':(
        None,
        _('Select one or more certificate fields to be used to authenticate:')),
    'uid':(
        None,
        _('Enter the attribute which contains the User ID for '
          'SMTP authentication:')),
}

authtypes = {
    'anonymous':None,
    'password':{'user':'cn=Anonymous', 'password':''},
    }

# Even though this is "servers", it's really a server-group
servers = {}
queries = {}
max_recurse_depth = 5
interface = ''

# The number of queries that may be sent over a single connection before
# it is shut down and restarted (subject to a random fuzz factor)
max_requests_per_connection = 10000

# The number of seconds that a single connection may live before it is
# shut down and restarted (subject to a random fuzz factor)
max_time_per_connection = 21600

# does this query have addresses?  if not, it's a pure group query.
query_has_addr_re = re.compile("\{[aud]\}")

cache_size_default = 10000
cache_ttl_default = 0

# Should we cache negative results?  Defaults to on, and currently has
# no user interface, but I'm slipping this in for experimental AE use.
# WARNING: This will cause work-queue queries to happen twice, it's
# only useful for LDAP Accept queries in the conversation.
cache_negative = 1

# Silently ignore failed group queries. Will include group queries
# in the preload cache step if set to zero.
silent_group_failures = 1

# Diagnostic timeouts.  When a client is used during testing (via the
# UI), shorter timeouts are desirable.
DIAGNOSTIC_OPERATION_TIME = 5
DIAGNOSTIC_FAILOVER_TIME = 7

# Amount of time to wait between retries when a server is down
SERVER_DOWN_RETRY_TIME = 60

# Domain-based meta-query table entry types
STRING_TYPE_FQDN = 1
STRING_TYPE_PARTIAL = 2
STRING_TYPE_UNKNOWN = 3

# Common strings
DOMAIN_BASED_LABEL = 'META-DOMAIN-BASED'
CHAINED_LABEL      = 'META-DAISY-CHAINED'

# LDAP error codes to handle
errors_to_handle = {}

# LDAP Exceptions
#################
# This is raised by ldap_api.query when it calls its function to get
# the query name and gets None back. It's not a bad exception, it's
# just a "hey, you didn't give me anything to query" kind of thing.
class LDAP_Noop (Exception):
    pass

# This is raised by .query if the address cannot be usefully parsed by
# address parser.
class LDAP_Invalid_Address (Exception):
    pass

# This is raised by the domain-masquerade code if a server failure
# condition arises.  Most other server-failures are handled via
# (non-Exception) result code.
class LDAP_Server_Failure (Exception):
    pass

# SMTPAUTH details
##################

SMTPAUTH_REGEXP = re.compile('^\{(.*?)\}(.*)$')

def is_smtpauth_bind(ldapquery):
    """is_smtpauth_bind(ldapquery) -> Boolean

    Is this query an SMTP auth query configured to use bind instead of
    query?

    """
    return (ldapquery['type'] in ['smtpauth','isqauth']) \
           and ldapquery.get('max_connections', 0)

def smtpauth_authtype(ldapquery):
    """smtpauth_authtype(ldapquery) -> authtype string

    Return either 'bind' or 'fetch'

    """
    if is_smtpauth_bind(ldapquery):
        return 'bind'
    else:
        return 'fetch'

### Encryption functions (for encoding incoming passwords for comparisons)
# In the following functions, <password> is in plaintext.  They are
# converted to their counterpart representations (e.g. md5, etc),
# and compared to <value_from_ldap>.

def pw_md5_validate(password, value_from_ldap):
    try:
        encpw = binascii.b2a_base64(sslip2.md5(password).digest())[:-1]
    except sslip2.Error:
        # In FIPS mode md5 is not supported and will raise an error.
        return False
    return encpw == value_from_ldap

def pw_sha_validate(password, value_from_ldap):
    encpw = binascii.b2a_base64(sslip2.sha1(password).digest())[:-1]
    return encpw == value_from_ldap

def pw_ssha_validate(password, value_from_ldap):
    # If value returned by LDAP has bad encoding, fail.
    try:
        decoded_vfl = binascii.a2b_base64(value_from_ldap)
    except binascii.Error:
        return False

    # Salt for SSHA is everything after byte 20
    vfl_sha = decoded_vfl[:20]
    salt = decoded_vfl[20:]
    encpw = sslip2.sha1(password + salt).digest()

    return encpw == vfl_sha

def pw_crypt_validate(password, value_from_ldap):
    # If the value in LDAP begins with '$1$', the password is stored in
    # crypt MD5 format, and salt is considered the first 11 characters.
    if value_from_ldap.startswith('$1$') and len(value_from_ldap) == 34:
        salt = value_from_ldap[:11]
        # BUG 11168, If crypt fails because an argument has null bytes,
        # fail silently.
        try:
            encpw = crypt.crypt(password, salt)
        except TypeError:
            return False
    else:
        # Use traditional crypt: salt is the first 2 characters
        salt = value_from_ldap[:2]
        try:
            encpw = crypt.crypt(password, salt)
        except TypeError:
            return False

    return encpw == value_from_ldap

passwd_validators = {
    'plain': operator.eq,
    'md5': pw_md5_validate,
    'sha': pw_sha_validate,
    'sha1': pw_sha_validate,
    'ssha': pw_ssha_validate,
    'crypt': pw_crypt_validate,
}

# Search pattern to handle the comment delimiter in user part oddity
clp_re = re.compile("(?<!\\\\)\(")

# Address sanitation
def sanitize_address(address, clp_process=True):
    address = address.strip()       # might as well strip it
    if not address:                 # these could be empty from bounces
        raise LDAP_Invalid_Address()

    # If it doesn't looks like an email address, then just return
    if address.find('@') == -1:
        return address

    try:
        tmp_address = rfc_2822_parse.cleanse_address(address)
        if not tmp_address:
            if clp_process and clp_re.search(address):
                return sanitize_address(clp_re.sub("\\(", address), False)
            else:
                raise LDAP_Invalid_Address()
        return tmp_address
    except rfc_2822_parse.ParseError:
        raise LDAP_Invalid_Address()

# "ldap_entry" result class
# tdraegen XXX - eventually this can be disappeared; just process
# ldap_client results directly.
class ldap_entry:
    def __init__ (self, localAddress=None, mailHost='',
                  routingAddress=None, groupMembers=None, userPassword=None,
                  callAheadHost=''):
        self.localAddress = localAddress or []
        self.mailHost = mailHost
        self.routingAddress = routingAddress or []
        self.callAheadHost = callAheadHost
        self.groupMembers = groupMembers or []
        self.userPassword = userPassword or []
        # This setting is used in routing query to indicate the entry is
        # 'final' - it should not be rerouted again, and also should appear
        # in the final result
        self.final = False

    def __repr__ (self):
        parts = []
        if self.localAddress: parts.append("local=%r"%self.localAddress)
        if self.routingAddress: parts.append("routing=%r"%self.routingAddress)
        if self.mailHost: parts.append("host=%r"%self.mailHost)
        if self.callAheadHost:
            parts.append("callaheadhost=%r" % (self.callAheadHost,))
        if self.groupMembers: parts.append("group=%r"%self.groupMembers)
        if self.userPassword: parts.append("userPassword=%r"%self.userPassword)
        return "<LDAP:%s>" % ",".join(parts)

    def is_empty (self):
        return not (self.localAddress or self.mailHost or
                    self.routingAddress or self.callAheadHost
                    or self.groupMembers or self.userPassword)

    def merge_with (self, entry):
        self.localAddress.extend (entry.localAddress)
        self.routingAddress.extend (entry.routingAddress)
        self.groupMembers.extend (entry.groupMembers)
        self.userPassword.extend (entry.userPassword)
        if entry.mailHost:
            self.mailHost = entry.mailHost
        if entry.callAheadHost:
            self.callAheadHost = entry.callAheadHost

def _strip_smtp_colon(s):
    if s.lower().startswith('smtp:'):
        s=s[5:]
    return s

def indirect_get(key, default, query, attrs):
    try:
        indirect_key = query[key]
        if indirect_key is None:
            return default
        return attrs[indirect_key.lower()]
    except KeyError:
        return default

def is_query_meta(query):
    """is_query_meta(query)
    Determine whether or not supplied query is "meta", which means
    domain-based or daisy-chained."""
    return query['query'] in [DOMAIN_BASED_LABEL, CHAINED_LABEL]

def accept_result_to_ldap_entry(raw_result):
    """ Convert a raw accept LDAP result into an ldap_entry.
        Accept just wants to know if there is *any* non-zero result.
        raw_result is (Bool, [list is discovered stuff])
    """
    return raw_result

def route_result_to_ldap_entry(raw_result, query):
    """ Convert a raw route LDAP result into an ldap_entry.

        Routing relies on (indirect) attributes:
            - mailRoutingAddress
            - mailHost
            - callAheadHost
    """
    success, unprocessed_res = raw_result
    if success:
        results = []
        for dn, attrs in unprocessed_res:

            # Don't care about "dn" in ROUTE context

            # Giving up and using force.  I don't want to lower() all
            # of these keys in ldap_client, because we may want to
            # display them in the future, but these won't get again,
            # so stomp 'em

            # lower() all the keys and strip smtp: from the vals
            attrs_lower = {}
            for key, val in attrs.items():
                # be safe and don't screw with other types, just in case
                if type(val) == types.ListType or type(val) == types.TupleType:
                    val = [_strip_smtp_colon(elem) for elem in val]
                attrs_lower[key.lower()] = val
            attrs = attrs_lower

            # XXX perhaps strip 'smtp:' in here instead XXX
            mailHost = None
            if query.has_key('mailhost'):
                mailHost = indirect_get('mailhost', [], query, attrs)
                if mailHost and len(mailHost)>0:
                    mailHost = mailHost[0]
            if mailHost:
                mailHost = mailHost.strip()
                mailHost = mailHost.lower()

            callAheadHost = None
            if query.has_key('callaheadhost'):
                callAheadHost = indirect_get('callaheadhost', [], query, attrs)
                if callAheadHost and len(callAheadHost) > 0:
                    callAheadHost = callAheadHost[0]
                if callAheadHost:
                    callAheadHost = callAheadHost.strip()
                    callAheadHost = callAheadHost.lower()

            routingAddress = None
            if query.has_key('mailroutingaddress'):
                routingAddress = indirect_get('mailroutingaddress', [],
                                               query, attrs)

            # break multiple routing address entries apart
            if routingAddress:
                for addr in routingAddress:
                    if addr:
                        addr = addr.strip()
                    results.append(
                        ldap_entry(
                            localAddress=None,
                            routingAddress=[addr],
                            mailHost=mailHost,
                            callAheadHost=callAheadHost,
                            groupMembers=None,
                            userPassword=None))
            else:
                results.append(
                    ldap_entry(
                        localAddress=None,
                        routingAddress=routingAddress,
                        mailHost=mailHost,
                        callAheadHost=callAheadHost,
                        groupMembers=None,
                        userPassword=None))

        return (True, results)
    else:
        return raw_result

def masquerade_result_to_ldap_entry(raw_result, query):
    """ Convert a raw LDAP masquerade result into an ldap_entry.

        Masquerading relies on (indirect) attributes:
            - mailLocalAddress
    """
    success, unprocessed_res = raw_result
    if success:
        results = []
        for dn, attrs in unprocessed_res:

            # Don't care about "dn" in MASQUERADE context

            # Giving up and using force.  I don't want to lower() all
            # of these keys in ldap_client, because we may want to
            # display them in the future, but these won't get again,
            # so stomp 'em

            # lower() all the keys and strip smtp: from the vals
            attrs_lower = {}
            for key, val in attrs.items():
                # be safe and don't screw with other types, just in case
                if type(val) == types.ListType or type(val) == types.TupleType:
                    val = [_strip_smtp_colon(elem) for elem in val]
                attrs_lower[key.lower()] = val
            attrs = attrs_lower

            localAddress = None
            if query.has_key ('maillocaladdress'):
                localAddress = indirect_get('maillocaladdress', [],
                                            query, attrs)

            results.append(
                ldap_entry(
                    localAddress=localAddress,
                    routingAddress=None,
                    mailHost=None,
                    groupMembers=None,
                    userPassword=None))

        return (True, results)
    else:
        return raw_result

def group_result_to_ldap_entry(raw_result, query):
    """ Convert a raw LDAP group result into an ldap_entry.

        Group relies on (indirect) attributes:
            - groupMembers
    """
    success, unprocessed_res = raw_result
    if success:
        results = []
        for dn, attrs in unprocessed_res:

            # Don't care about "dn" in GROUP context

            # Giving up and using force.  I don't want to lower() all
            # of these keys in ldap_client, because we may want to
            # display them in the future, but these won't get again,
            # so stomp 'em

            # lower() all the keys and strip smtp: from the vals
            attrs_lower = {}
            for key, val in attrs.items():
                # be safe and don't screw with other types, just in case
                if type(val) == types.ListType or type(val) == types.TupleType:
                    val = [_strip_smtp_colon(elem) for elem in val]
                attrs_lower[key.lower()] = val
            attrs = attrs_lower

            groupMembers = None
            if query.has_key ('groupmembers'):
                groupMembers = indirect_get('groupmembers', [], query, attrs)

            # empty ldap_entry is treated as failure. Just append the raw
            # result instead of appending an empty ldap_entry
            if groupMembers is None:
                results.append((dn, attrs))
                continue

            results.append(
                ldap_entry(
                    localAddress=None,
                    routingAddress=None,
                    mailHost=None,
                    groupMembers=groupMembers,
                    userPassword=None))

        return (True, results)
    else:
        return raw_result

def smtpauth_fetch_result_to_ldap_entry(raw_result, query):
    """ Convert a raw LDAP smtpauth (fetch-based auth type) result into
        an ldap_entry.

        SMTPAUTH relies on (indirect) attributes:
            - userPassword
    """
    success, unprocessed_res = raw_result
    if success:
        results = []
        for dn, attrs in unprocessed_res:

            # Don't care about "dn" in 'fetch' auth-type SMTPAUTH context

            # Giving up and using force.  I don't want to lower() all
            # of these keys in ldap_client, because we may want to
            # display them in the future, but these won't get again,
            # so stomp 'em

            # lower() all the keys and strip smtp: from the vals
            attrs_lower = {}
            for key, val in attrs.items():
                # be safe and don't screw with other types, just in case
                if type(val) == types.ListType or type(val) == types.TupleType:
                    val = [_strip_smtp_colon(elem) for elem in val]
                attrs_lower[key.lower()] = val
            attrs = attrs_lower

            userPassword = None
            if query.has_key('userpassword'):
                userPassword = indirect_get('userpassword', [], query, attrs)

            results.append(
                ldap_entry(
                    localAddress=None,
                    routingAddress=None,
                    mailHost=None,
                    groupMembers=None,
                    userPassword=userPassword))

        return (True, results)
    else:
        return raw_result

def smtpauth_bind_dn_result_to_ldap_entry(raw_result):
    """ Convert a raw LDAP smtpauth (bind-based auth type) result into an
        ldap_entry.

        This is part 1 of the 2 part process.  Simply discover the DN.
    """
    success, unprocessed_res = raw_result
    if success:
        dn_results = []
        for dn, attrs in unprocessed_res:

            # Only care about DN results for 'bind' part 1
            dn_results.append(dn)

        return (True, dn_results)
    else:
        return raw_result

def smtpauth_bind_auth_result_to_ldap_entry(raw_result):
    """Convert a raw LDAP smtpauth (bind-based auth type) result into an
    ldap_entry.

    This is part 2 of the 2 part process.  Process results of
    DN + password BIND, which arrive in the form of (BOOL, DATA),
    where:

        (True, {True, False})
        (False, string)
    """
    return raw_result

def qlog_without_duplicates(logged_errors, err, queryname, result):
    if err in logged_errors:
        return
    # If it is the inquiry timeout error, generate warning message instead of
    # critical error which is debounced.
    if result == ldap_client.INQUIRY_TIMED_OUT:
        err = 'LDAP.WARNING'
    qlog.write(err, queryname, result)
    logged_errors.append(err)


# Steal stuff from ui_checker to avoid circular import mess
class ValidationError (Exception):
    pass
hostname_test = re.compile('([a-zA-Z0-9]([-_a-zA-Z0-9]*[a-zA-Z0-9])?\.)+(([a-zA-Z0-9][-_a-zA-Z0-9]*)?[A-Za-z]([-_a-zA-Z0-9]*[a-zA-Z0-9])?)$')
hostname_loose_pat = '([a-zA-Z0-9]([-_a-zA-Z0-9]*[a-zA-Z0-9])?\.)*(([a-zA-Z0-9][-_a-zA-Z0-9]*)?[A-Za-z]([-_a-zA-Z0-9]*[a-zA-Z0-9])?)$'
hostname_loose_test = re.compile(hostname_loose_pat)
def validate_hostname(hostname):
    if hostname_test.match(hostname):
        return hostname
    else:
        raise ValidationError
def validate_hostname_loose(hostname):
    if hostname_loose_test.match(hostname):
        return hostname
    else:
        raise ValidationError
def validate_partial_host(host):
    if host and ((host[0]=='.' and validate_hostname_loose(host[1:]) or
                    validate_hostname(host)
                    )
                ):
        return host
    else:
        raise ValidationError

def member_type(member):
    """member_type(member) -> member_type
    Returns the type of the given member. <member_type> may be
    STRING_TYPE_FQDN, STRING_TYPE_PARTIAL, STRING_TYPE_UNKNOWN.
    """
    try:
        validate_hostname(member)
        return STRING_TYPE_FQDN
    except ValidationError:
        pass
    try:
        validate_partial_host(member)
        return STRING_TYPE_PARTIAL
    except ValidationError:
        pass
    return STRING_TYPE_UNKNOWN

def address_to_domain_table_entry(address, domain_tables, default_query):
    """address_to_domain_table_entry(address, domain_tables)
    Given the supplied address and domain_tables, return a matching
    queryname."""
    query_name = None
    lowered_address = address.lower()
    lowered_username, hostname = ironutil.addr_split(lowered_address)
    fqdn_table, partial_table = domain_tables

    if fqdn_table.has_key(hostname):
        query_name = fqdn_table[hostname]
    else:
        hostname_pieces = hostname.split('.')
        for x in xrange(1, len(hostname_pieces)):
            host_part = "." + '.'.join(hostname_pieces[x:])
            if partial_table.has_key(host_part):
                query_name = partial_table[host_part]
                break
    if query_name is None:
        query_name = default_query
    return query_name

def address_from_query_type(query, *args):
    """Obtain address from supplied arguments.

    The address is used to select proper query for domain-based
    queries.

    :Parameters:
        - `query`: dictionary containing domain-based query params.
        - `args`: tuple of arguments.  It depends on query type.

    :Return:
        A string containing address.
    """

    if query['type'] == 'externalauth' or (len(args) and len(args) <= 3):
        if args[0] is not None:
            return args[0]

    qlog.write('LDAP.ERROR', '?', "LDAP domain-based QUERY cannot resolve an address.")
    raise LDAP_Noop

# "ldap_api" runtime object class
class ldap_api:
    def __init__ (self):
        self.servergroups = {}
        self.queries = {}
        self.meta_query_cache = {}
        self.clear_cache_callbacks = []

        self.local_interface = ''
        self.bind_ip = None

        # app's global ldap_client context
        self.ldap_client = None
        self.status_msg = None

    def initialize(self):
        self.ldap_client = ldap_client.ldap_client()

    def debug_log(self,who,msg):
        if who:
            w_msg = "(" + who + ") " + msg
        else:
            w_msg = msg
        qlog.write ('LDAP.DEBUG', w_msg,)
        if self.status_msg is not None:
            self.status_msg.append(msg)

    def start_log(self):
        self.status_msg = []

    def get_log(self):
        return self.status_msg

    # cache stuff
    def clear_cache(self, who = None):
        """clear_cache(new_size=0) -> None
        """
        self.ldap_client.clear_all_caches()
        for callback in self.clear_cache_callbacks:
            callback()

    # client context stuff
    def update_local_interface(self, iface):
        self.local_interface = iface
        if self.local_interface != '':
            try:
                self.bind_ip = \
                    network_manager.interfaces[self.local_interface]['ip']
            except KeyError:
                self.bind_ip = None
        else:
            self.bind_ip = None

        # Changing "bind_ip" requiries rebuilding server-groups.

    def update_for_diagnostic_run(self):
        """update_for_diagnostic_run(op_time, failover_time)
        Update the ldap_client for use as a diagnostic client."""
        for key in self.servergroups.keys():

            # Does this one exist?
            this_sg = self.ldap_client.get_server_group(key)
            if this_sg is None:
                # Skip non-existing ones
                pass
            else:
                this_sg.set_operation_timeout(DIAGNOSTIC_OPERATION_TIME)
                this_sg.set_failover_timeout(DIAGNOSTIC_FAILOVER_TIME)
                # Fudge up inquiry timeout to something reasonable
                this_sg.set_inquiry_timeout(DIAGNOSTIC_FAILOVER_TIME *
                                           max(2, this_sg.get_number_of_servers()))

    def refresh_queries(self, new_queries):
        """Populate ldap-client's queries using queries config blob.
        Maintain a meta-query cache for fast lookups."""
        self.queries = new_queries
        self.meta_query_cache = {}
        for query_name, query in new_queries.items():
            adv_query = query.get('query')
            if adv_query == DOMAIN_BASED_LABEL:
                raw_map = query['domainmap']
                fqdn_table = {}
                partial_table = {}
                for domain, queryname in raw_map.items():
                    mtype = member_type(domain)
                    if mtype == STRING_TYPE_FQDN:
                        fqdn_table[domain] = queryname
                    elif mtype == STRING_TYPE_PARTIAL:
                        partial_table[domain] = queryname
                    else:
                        raise AssertionError, 'invalid member_type %r (%s)' % \
                                              (mtype, domain)
                self.meta_query_cache[query_name] = (fqdn_table, partial_table)

            elif adv_query == CHAINED_LABEL:
                self.meta_query_cache[query_name] = query['chainlist']
            elif query.get('type') == 'smtpauth':
                server = query.get('server')
                max_connections = query.get('max_connections',
                                            ldap_client.DEFAULT_MAX_BIND_CONNS)
                sg = self.ldap_client.get_server_group(server)
                if sg:
                    sg.set_max_bind_connections(max_connections)

    def create_new_server_group(self, name, config_dict, maximum_connections=0):
        """create_new_server_group(config_dict)
        Create and start a server_group using the supplied
        configuration dictionary.   Config dict is one of the
        servers found in global "servers" dict.
        Due to 45194 maximum_connections is introduced.
        Use maximum_connections if it is passed in
        else use server default from config dict.
        EUQ and EUQ UI will pass in maximum_connections=1.
        ISQ will use user configured max_connections for the server.
        """
        global max_time_per_connection, max_requests_per_connection

        hostnames = config_dict['hostname'].split(',')

        # Client will figure out correct port based on TRANSPORT
        port = int(config_dict['port'])

        authtype = config_dict['authtype']
        authdata = config_dict['authdata']

        if config_dict['use_ssl']:
            transport = ldap_client.TRANSPORT_SSL
        else:
            transport = ldap_client.TRANSPORT_PLAINTEXT

        compatibility = config_dict.get('compatibility',
                                    ldap_client.DEFAULT_COMPATIBILITY)

        if config_dict.has_key('connection_behavior'):
            if config_dict['connection_behavior'] == 'failover':
                conn_behavior = ldap_client.CONNECT_BEHAVIOR_FAILOVER
            else:
                assert(config_dict['connection_behavior']
                       == 'load_balance')
                conn_behavior = \
                    ldap_client.CONNECT_BEHAVIOR_LOAD_BALANCE
        else:
            conn_behavior = ldap_client.CONNECT_BEHAVIOR_FAILOVER

        if maximum_connections:
            max_conns = maximum_connections
        else:
            max_conns = config_dict.get('max_connections',
                                        ldap_client.DEFAULT_MAX_CONNS)

        # Check for max bind connections
        max_bind_conns = ldap_client.DEFAULT_MAX_BIND_CONNS
        for query_name, query in self.queries.items():
            if query.get('type') == 'smtpauth' and query.get('server') == name:
                max_bind_conns = query.get('max_connections',
                                           ldap_client.DEFAULT_MAX_BIND_CONNS)

        cache_size = config_dict.get('cache_size',
                                    ldap_client.DEFAULT_CACHE_SIZE)
        cache_ttl = config_dict.get('cache_ttl',
                                    ldap_client.DEFAULT_CACHE_TTL)

        # Create a new server group, populate it with servers
        new_sg = self.ldap_client.create_server_group(name,
                   behavior=conn_behavior, bind_ip=self.bind_ip)
        new_sg.set_compatibility(compatibility)
        new_sg.set_max_connections(max_conns)
        new_sg.set_max_bind_connections(max_bind_conns)
        new_sg.set_cache_size(cache_size)
        new_sg.set_cache_ttl(cache_ttl)

        # Not user-configurable, but can be changed by AE/support
        new_sg.set_max_time_per_connection(max_time_per_connection)
        new_sg.set_max_requests_per_connection(max_requests_per_connection)

        for host in hostnames:
            # Create servers
            new_sg.add_server(host.strip(), port, authtype, authdata,
                              transport)
        # Kick it off
        new_sg.start()

    def refresh_servergroups(self, server_groups, maximum_connections = 0):
        """refresh_servergroups(server_groups) -> None

        Maintain our ldap-client's server-groups.

        """
        old_servers = self.servergroups
        self.servergroups = server_groups

        # Remove servergroups that are no longer with us
        for key in old_servers:
            if not self.servergroups.has_key(key):
                self.ldap_client.remove_server_group(key)

        # Walk each new/existing server and check if there are any changes
        for key in self.servergroups.keys():

            # Does this one exist?
            this_sg = self.ldap_client.get_server_group(key)
            if this_sg is None:
                self.create_new_server_group(key, self.servergroups[key], maximum_connections)

            else:
                # Servergroup currently exists.  Does it need an update?
                if old_servers.has_key(key):

                    refresh_server_group = False
                    config_dict = self.servergroups[key]

                    # For each config var, determine if it has been changed
                    old_srv = old_servers[key]

                    # Settings that require a new server-group
                    if old_srv.has_key('connection_behavior'):
                        if old_srv['connection_behavior'] != config_dict['connection_behavior']:
                            refresh_server_group = True
                    # "bind_ip" comes from a different configuration blob

                    # Settings that require replacing existing server.
                    #
                    # It's possible to replace individual servers, but
                    # constructing a new server-group is easy.
                    if old_srv.has_key('hostname'):
                        if old_srv['hostname'] != config_dict['hostname']:
                            refresh_server_group = True

                    if old_srv.has_key('port'):
                        if old_srv['port'] != config_dict['port']:
                            refresh_server_group = True

                    if old_srv.has_key('authtype'):
                        if old_srv['authtype'] != config_dict['authtype']:
                            refresh_server_group = True

                    if old_srv.has_key('authdata'):
                        if old_srv['authdata'] != config_dict['authdata']:
                            refresh_server_group = True

                    if old_srv.has_key('transport'):
                        if old_srv['transport'] != config_dict['transport']:
                            refresh_server_group = True

                    # Only do the following if a refresh isn't already happening
                    if not refresh_server_group:
                        if old_srv.has_key('compatibility'):
                            if old_srv['compatibility'] != config_dict['compatibility']:
                                sg = self.ldap_client.get_server_group(key)
                                sg.set_compatibility(config_dict['compatibility'])
                        if (old_srv.has_key('max_connections') and not maximum_connections):
                            if old_srv['max_connections'] != config_dict['max_connections']:
                                sg = self.ldap_client.get_server_group(key)
                                sg.set_max_connections(config_dict['max_connections'])
                        if old_srv.has_key('cache_size'):
                            if old_srv['cache_size'] != config_dict['cache_size']:
                                sg = self.ldap_client.get_server_group(key)
                                sg.set_cache_size(config_dict['cache_size'])
                        if old_srv.has_key('cache_ttl'):
                            if old_srv['cache_ttl'] != config_dict['cache_ttl']:
                                sg = self.ldap_client.get_server_group(key)
                                sg.set_cache_ttl(config_dict['cache_ttl'])
                    else:
                        # Teardown existing server-group
                        self.ldap_client.remove_server_group(key)

                        # Make a new one
                        self.create_new_server_group(key, self.servergroups[key], maximum_connections)

    def disconnect_from_servers(self):
        # called from:
        #  hermes/hermes.py:        my_ldap.disconnect_from_servers()
        #  hermes/omh/omh.py:            use_ldap_api.disconnect_from_servers()
        if self.ldap_client:
            self.ldap_client.destroy_client()
            self.ldap_client = None

    # Shared bind-to-raw-result util
    def _result_from_bind(self, who, server_dict, username, password):
        """Returns result from bind operations.

        :Parameters:
            - `who`: string represnting caller.  It is used for logging.
            - `server_dict`: dictionary of server settings.
            - `username`: username to log in with.  Usually is a DN.
            - `password`: user pasword.

        :Return:
            Tuple of two items.  First item is in turn a tuple of two boolean
            (success, result).  success indicates if server was up, result
            contains the result of bindoperation. Second item is a string
            containing an error description in case of error or connection name
            in case of success.
        """

        global errors_to_handle
        # Implements previously known "binder_client" functionality
        self.debug_log(who, "Bind attempt to server %s (%s:%d)" % (
                       server_dict["name"],
                       server_dict['hostname'], server_dict['port']))
        # Grab the server-group
        bind_sg = self.ldap_client.get_server_group(server_dict["name"])
        if bind_sg is None:
            return (False, 'no server "%s" found for specified query' % server_dict["name"])

        # "results" is a (BOOL, data) tuple
        (results,resolver) = bind_sg.simple_bind_query(username, password,
                                                       errors_to_handle.keys())

        return results

    # Shared query-to-raw-result util
    def _result_from_query(self, query_string, query_name, server_dict,
                           look_for_attrs, who, logged_errs,
                           query_syntax_error='LDAP.ERROR', base_dn=None):
        """ return results from query
        By default, logging query syntax error as LDAP.ERROR, this allow
        the caller (ie. smtpauth) to set the desired level.
        """
        global errors_to_handle
        results = None

        # Lookup the server-group for this query
        sgroup = self.ldap_client.get_server_group(server_dict["name"])
        if sgroup is None:
            return ((False, 'no server "%s" found for specified query' %
                server_dict["name"]), None)

        self.debug_log(who, "Query %s to server %s (%s:%d)" % (
           query_string,
           server_dict['name'],
           server_dict['hostname'], server_dict['port']))

        try:
            results = sgroup.search_query(query_string, base_dn or
                server_dict['base'], look_for_attrs, errors_to_handle.keys())

        except ldap.QuerySyntaxError, e:
            import shared.LDAP
            # This error came from our encoder, and is
            # serious.  It should mean that the user has
            # entered an invalid query, and LDAP processing
            # will grind to a halt.

            # This one has the detail, and will only go to the
            # LDAP debug log where it won't hurt anyone.
            self.debug_log(who, "Query Syntax Error in %s, %s" % (query_name, str(e)))

            # log this error normally, but make sure the
            # strings are identical so the debounce magic can
            # happen
            qlog_without_duplicates(logged_errs, query_syntax_error, query_name,
                "Query Syntax Error, see LDAP debug logs for detail")

            return ((False, shared.LDAP.LDAPResult_to_string(e)), None)

        except ldap.Error, e:
            import shared.LDAP
            # treat this as not-found
            # todo: handle specific error numbers
            qlog_without_duplicates(logged_errs, 'LDAP.ERROR', query_name, e)
            return ((False, shared.LDAP.LDAPResult_to_string(e)), None)

        if results is None:
            return ((False,[]),None)
        else:
            ((success, data), resolver) = results
            if success:
                return results
            else:
                import shared.LDAP
                return ((success, shared.LDAP.LDAPResult_to_string(data)), resolver)

    # hermes query API

    def _do_query_dn(self, get_queryname, address, mail_from,
                       try_only_once=True, query_type='accept'):
        """Query user DN.

        :Parameters:
            - `get_queryname`: Function which should return the tuple describing
                               the query.
            - `query_type`: String representing query type.
            - `address`: Email address of the receiver for substitution.
            - `mail_from`: Email address of the sender for substitution.
            - `try_only_once`: Do not retry query if True.

       :Return:
            Tuple of (server_up, raw_result), where server_up is boolean
            indicating if server is up.  raw_result is raw server reply.
        """
        # Sanitize arguments
        address = sanitize_address(address)

        # LDAPv3 requires attribute data to be in UTF-8
        try:
            u_addr = unicode(address, 'utf-8')
        except UnicodeDecodeError:
            try:
                u_addr = unicode(address, 'iso-8859-1')
            except UnicodeDecodeError:
                raise LDAP_Invalid_Address()
            address = u_addr.encode('utf-8')

        # No need to do a cleanse_address on mail_from, since the injector
        # code will already have done it.

        # Current heuristic is to attempt connectivity forever, every
        # 60 seconds.  Must apply heurstic here to allow get_queryname()
        # to return different data in the case of a config update.
        logged_errs = []
        while 1:
            queryname, query, server = self._get_query_data(get_queryname)

            # Deal with meta queries
            if query['query'] == DOMAIN_BASED_LABEL:
                return self._domain_table_lookup(query_type, queryname,
                                                 query, self,
                                                 ldap_api._do_query_dn,
                                                 address, mail_from,
                                                 try_only_once=try_only_once,
                                                 query_type=query_type)

            elif query['query'] == CHAINED_LABEL:
                return self._daisy_chain_lookup(query_type, queryname, self,
                                                ldap_api._do_query_dn,
                                                address, mail_from, try_only_once=try_only_once,
                                                query_type=query_type)

            query_string = self._do_substitution(query['query'], address, None, mail_from)

            # No additional attributes to look, pass empty list

            results, resolver = self._result_from_query(query_string, queryname,
                                              server, [], query_type, logged_errs)

            # Process results
            server_up, server_result = accept_result_to_ldap_entry(results)
            if server_up:
                self.debug_log(query_type, "Query %s lookup success, %s returned %s results" % (query_string, resolver, len(server_result)))
                return (server_up, server_result)
            else:
                self.debug_log(query_type, "Query %s lookup failed: %s" % (query_string, server_result))
                qlog_without_duplicates(logged_errs, 'LDAP.ERROR', queryname,
                                        server_result)
                if try_only_once:
                    return (server_up, server_result)
            coro.sleep_relative(SERVER_DOWN_RETRY_TIME)


    def query_accept(self, get_queryname, address, mail_from,
                     try_only_once=True):
        """
        get_queryname - function which should return the tuple below
        args - email address, envelope sender
        """
        return self._do_query_dn(get_queryname, address, mail_from,
                                 try_only_once=True, query_type='accept')


    def query_user_dn(self, get_queryname, address, try_only_once=True):
        """Get user destinguished name.

        :Parameters:
            - `get_queryname`: callable object which returns query name.
            - `address`: email address of the user.
            - `try_only_once`: if True the result (whatever success or
              failure) will be returned immediately, otherwise the query
              will retry until success.

        :Return:
            Tuple of (server_up, raw_result), where server_up is boolean
            indicating if server is up.  raw_result is raw server reply.
        """

        return self._do_query_dn(get_queryname, address, None,
                                 try_only_once=try_only_once, query_type='userdn')

    def _do_query_route(self, get_queryname, email_addr, try_only_once, query_type='route'):
        address = email_addr
        address = sanitize_address(address)

        # Current heuristic is to attempt connectivity forever, every
        # 60 seconds.  Must apply heurstic here to allow get_queryname()
        # to return different data in the case of a config update.
        logged_errs = []
        while 1:
            queryname, query, server = self._get_query_data(get_queryname)

            # Deal with meta queries
            if query['query'] == DOMAIN_BASED_LABEL:
                return self._domain_table_lookup(query_type, queryname,
                                                 query, self,
                                                 ldap_api._do_query_route,
                                                 address,
                                                 try_only_once=try_only_once)

            elif query['query'] == CHAINED_LABEL:
                return self._daisy_chain_lookup(query_type, queryname, self,
                                                ldap_api._do_query_route,
                                                address, try_only_once=try_only_once)

            query_string = self._do_substitution(query['query'], address, None, None)

            # Include additional "route" attributes
            look_for_attrs = []
            for indirect_attr_name in ('mailhost',           # reroute
                                       'mailroutingaddress', # reroute
                                       'callaheadhost'):     # call-ahead
                try:
                    actual_attr_name = query[indirect_attr_name]
                    if (actual_attr_name is not None) \
                       and (actual_attr_name not in look_for_attrs):
                        look_for_attrs.append(actual_attr_name)
                except KeyError:
                    pass

            results, resolver = self._result_from_query(query_string, queryname, server,
                                              look_for_attrs, query_type,
                                              logged_errs)
            server_up, server_result = route_result_to_ldap_entry(results, query)
            route_by_addr = (query['query'].find("{a}") >= 0)
            if server_up:
                self.debug_log(query_type, "Query %s lookup success, %s returned %s results" % (query_string, resolver, len(server_result)))
                return (server_up, server_result, route_by_addr)
            else:
                self.debug_log(query_type, "Query %s lookup failed: %s" % (query_string, server_result))
                qlog_without_duplicates(logged_errs, 'LDAP.ERROR', queryname,
                                        server_result)
                if try_only_once:
                    return (server_up, server_result, route_by_addr)
            coro.sleep_relative(SERVER_DOWN_RETRY_TIME)

    def query_route(self, get_queryname, email_addr, try_only_once=True, ordered_result=None, query_type='route'):
        """
        get_queryname - function which should return the tuple below
        args - email address
        """
        class LdapError:
            def __init__(self, srv_up, entries):
                self.srv_up = srv_up
                self.entries = entries

        def get_uid(addr):
            """Return the user part of email address with the presumption that
            the mail address has been cleansed, parsed."""
            idx = addr.find('@')
            if idx >= 0:
                return addr[0:idx]
            else:
                return addr

        def iter(api, addr, route_by_addr, results, routed_addrs, lower_addrs):
            ret_val = api._do_query_route(get_queryname, addr, try_only_once,
                                          query_type)
            srv_up, entries = ret_val[:2]
            if len(ret_val) == 3:
                route_by_addr = ret_val[2]
            # Save original value for display/logging purpose and lowercase for internal processing
            orig_addr = addr
            addr = addr.lower()
            if not srv_up:
                raise LdapError(srv_up, entries)
            else:
                if not entries:
                    return

            addr_entry = ldap_entry()
            for entry in entries:
                addr_entry.merge_with(entry)

            # If the matched record doesn't have any routing data
            if not (addr_entry.routingAddress or addr_entry.mailHost or
                    addr_entry.callAheadHost):
                return

            # Otherwise, mark the current addr or uid as 'routed'
            if addr_entry.routingAddress:
                # This is a valid self-routing use case with {u} query, i.e.
                # send myself a copy in addition to those other address
                if route_by_addr or (orig_addr not in addr_entry.routingAddress):
                    routed_addrs.add(orig_addr)
                    lower_addrs.add(addr)
                if not route_by_addr:
                    routed_addrs.add(get_uid(orig_addr))
                    lower_addrs.add(get_uid(addr))

            for entry in entries:
                if entry.routingAddress:
                    for new_addr in set(entry.routingAddress):
                        # Save original value for display/logging
                        orig_new_addr = new_addr
                        new_addr = new_addr.lower()
                        if new_addr == addr or new_addr not in lower_addrs:
                            new_addr_entry = ldap_entry()
                            # Self routing entry is considered final
                            if new_addr == addr:
                                new_addr_entry.final = True
                            new_addr_entry.merge_with(addr_entry)
                            new_addr_entry.routingAddress = [orig_new_addr]
                            results[orig_new_addr] = new_addr_entry
                            if ordered_result is not None:
                                ordered_result.append(new_addr_entry)
                            # Only attempt to reroute further if
                            # 1. We haven't seen this email before if routed by {a}
                            # 2. We haven't seen this user before if routed by {u}
                            # 3. The query_type is 'route', we don't need to reroute further if query is for 'primaryaddress'
                            if ((query_type == 'route') and route_by_addr and (new_addr not in lower_addrs)) or \
                               ((not route_by_addr) and (get_uid(new_addr) not in lower_addrs)):
                                iter(api, orig_new_addr, route_by_addr, results, routed_addrs, lower_addrs)
                elif entry.mailHost or entry.callAheadHost:
                    new_addr_entry = ldap_entry()
                    new_addr_entry.merge_with(addr_entry)
                    new_addr_entry.routingAddress = [orig_addr]
                    results[orig_addr] = new_addr_entry
                    if ordered_result is not None:
                        ordered_result.append(new_addr_entry)

        results = {} # return value
        try:
            queryname, query, server = self._get_query_data(get_queryname)
            # As long as there are {a} in the query, it is considered routed-
            # by-address.  Even if they are mixing both {a} and {u} in the query,
            # the {a} part will id a unique routed-from (source) address
            route_by_addr = (query['query'].find("{a}") >= 0)
            routed_addrs = set()
            iter(self, email_addr, route_by_addr, results, routed_addrs, set())
            # Delete the 'routed' address from the results.
            for addr in routed_addrs:
                if results.has_key(addr) and not results[addr].final:
                    del results[addr]
            # Delete the non-routing entry
            for addr in results.keys():
                entry = results[addr]
                if not (entry.routingAddress or entry.mailHost or
                        entry.callAheadHost):
                    del results[addr]
            self.debug_log(query_type, "results: %s" % (results,))
            return (True, results.values())
        except LdapError, e:
            return (e.srv_up, e.entries)

    def query_primaryaddress(self, get_queryname, email_addr, try_only_once=True):
        queryname, query, server = self._get_query_data(get_queryname)
        ordered_result = []
        success, query_route_result = self.query_route(get_queryname, email_addr, try_only_once, ordered_result=ordered_result, query_type="primaryaddress")
        if not success:
            return success, query_route_result

        # find the first result and return as a primary address
        for entry in ordered_result:
            if entry in query_route_result:
                # 2008-07-15 notes - things to be refactored:
                # remove call to filter_email_list from notify_task.py
                # remove reference to obsolete config var in notify_task.py, e.g. rv('euq.access.ldap_server_type')

                # Note we use '' for server_type below, the 'smtp:' prefix is already stripped in route_result_to_ldap_entry()
                # besides we don't have the server type defined here in case of chained query (bug 43247).
                if filter_email_list(entry.routingAddress, ''):
                    # 2008-07-14 why do we return a list of 1 instead? This is done
                    # to minimize code change in Plato FCS. It seems
                    # entry.routingAddress is actually the most appropriate result.
                    return success, [entry]
            # entry is filtered out? Try next one in the list.
        else:
            self.debug_log('primaryaddress', "Unable to find primary address - result: #%s ordered: #%s" % (
                len(query_route_result),len(ordered_result))
                )
            return success, []

    def query_masquerade(self, get_queryname, email_addr, try_only_once=True):
        """
        get_queryname - function which should return the tuple below
        args - email address
        """
        # work out the argument types
        address = sanitize_address(email_addr)

        # Current heuristic is to attempt connectivity forever, every
        # 60 seconds.  Must apply heurstic here to allow get_queryname()
        # to return different data in the case of a config update.
        logged_errs = []
        while 1:
            queryname, query, server = self._get_query_data(get_queryname)

            # Deal with meta queries
            if query['query'] == DOMAIN_BASED_LABEL:
                return self._domain_table_lookup('masquerade', queryname,
                                                 query, self,
                                                 ldap_api.query_masquerade,
                                                 address,
                                                 try_only_once=try_only_once)

            elif query['query'] == CHAINED_LABEL:
                return self._daisy_chain_lookup('masquerade', queryname, self,
                                                ldap_api.query_masquerade,
                                                address, try_only_once=try_only_once)

            query_string = self._do_substitution(query['query'], address, None, None)

            # Include additional "masquerade" attributes
            look_for_attrs = []
            indirect_attr_name = "maillocaladdress"
            try:
                actual_attr_name = query[indirect_attr_name]
                if (actual_attr_name is not None) \
                   and (actual_attr_name not in look_for_attrs):
                    look_for_attrs.append(actual_attr_name)
            except KeyError:
                pass

            results, resolver = self._result_from_query(query_string, queryname,
                                              server, look_for_attrs,
                                              'masquerade', logged_errs)
            server_up, server_result = masquerade_result_to_ldap_entry(results, query)
            if server_up:
                self.debug_log('masquerade', "Query %s lookup success, %s returned %s results" % (query_string, resolver, len(server_result)))
                return (server_up, server_result)
            else:
                self.debug_log('masquerade', "Query %s lookup failed: %s" % (query_string, server_result))
                qlog_without_duplicates(logged_errs, 'LDAP.ERROR', queryname,
                                        server_result)
                if try_only_once:
                    return (server_up, server_result)
            coro.sleep_relative(SERVER_DOWN_RETRY_TIME)

    def query_group(self, get_queryname, address_list, groupname, try_only_once=True):
        """
        get_queryname - function which should return the tuple below
        args - [email addresses], groupname

        Returns: (BOOL, data)
            If BOOL is False, query failed for some 'data' reason.
            If BOOL is True, query resolved.  'data' is list of addrs (
            can be empty list).
        """
        # Oh, what the hell... let the caller give us a single rcpt
        if isinstance(address_list, str):
            address_list = [address_list]
        if not address_list:
            raise LDAP_Invalid_Address()
        try:
            test_address = sanitize_address(address_list[0])
        except:
            return (True, [])   # see bug 36312

        # Current heuristic is to attempt connectivity forever, every
        # 60 seconds.  Must apply heurstic here to allow get_queryname()
        # to return different data in the case of a config update.
        logged_errs = []
        while 1:

            # aka old ldap_api.py::rcpts_in_group()
            # before calling query, decide whether this is an {aud}+{g} query
            # or just a {g} query
            queryname, query, server = self._get_query_data(get_queryname)

            # Deal with meta queries
            if query['query'] == DOMAIN_BASED_LABEL:
                return self._domain_table_lookup('group', queryname,
                                                 query, self,
                                                 ldap_api.query_group,
                                                 address_list[0], groupname,
                                                 try_only_once=try_only_once)

            elif query['query'] == CHAINED_LABEL:
                return self._daisy_chain_lookup('group', queryname, self,
                                                ldap_api.query_group,
                                                address_list, groupname, try_only_once=try_only_once)

            look_for_attrs = []
            indirect_attr_name = 'groupmembers'
            # Special case for deprecated {a}-less groups.  In the
            # normal case, where we have an {a}, we don't use this
            # field.  See bug 7800, sending the unused field
            # doesn't hurt anything, but is messy.
            if query['query'].find('{a}') == -1:
                try:
                    actual_attr_name = query[indirect_attr_name]
                    if (actual_attr_name is not None) \
                       and (actual_attr_name not in look_for_attrs):
                        look_for_attrs.append(actual_attr_name)
                except KeyError:
                    pass

            # {aud}+{g}
            if query_has_addr_re.search(query['query']):
                for addr in address_list:
                    # Sanitize each address
                    try:
                        addr = sanitize_address(addr)
                    except:
                        continue

                    query_string = self._do_substitution(query['query'], addr, groupname, None)

                    results, resolver = self._result_from_query(query_string, queryname,
                                                      server, look_for_attrs,
                                                      'group', logged_errs)

                    # Process the result.  Any returned entry is good enough
                    success, rez = group_result_to_ldap_entry(results, query)
                    if not success:
                        self.debug_log('group', "Query %s lookup failed: %s" %
                                       (query_string, rez))
                        qlog_without_duplicates(logged_errs, 'LDAP.ERROR',
                                                queryname, rez)
                        if try_only_once:
                            return (success, rez)
                    else:
                        self.debug_log('group', "Query %s lookup success, %s returned %d results" %
                                       (query_string, resolver, len(rez)))
                        if rez:
                            return (success, rez)
                return (True, [])
            # Fetch entire group and test rcpts (just {g})
            else:
                query_string = self._do_substitution(query['query'], None, groupname, None)
                results, resolver = self._result_from_query(query_string, queryname,
                                                  server, look_for_attrs,
                                                  'group', logged_errs)

                # Process raw result
                success, rez = group_result_to_ldap_entry(results, query)
                if not success:
                    self.debug_log('group', "Query %s lookup failed: %s" %
                                   (query_string, rez))
                    qlog_without_duplicates(logged_errs, 'LDAP.ERROR',
                                            queryname, rez)
                    if try_only_once:
                        return (success, rez)
                else:
                    self.debug_log('group', "Query %s lookup success, %s returned %d results" %
                                   (query_string, resolver, len(rez)))

                    if rez:
                        entries = rez[0] # groups aren't recursive yet
                        for addr in address_list:
                            if addr in entries.groupMembers:
                                return (True, [addr])
                    return (True, [])

            coro.sleep_relative(SERVER_DOWN_RETRY_TIME)

    def query_smtpauth(self, get_queryname, username, password, def_enc_type,
                       try_only_once=True, skip_allowance_check=False):
        """Run an "smtpauth" query type.

        :Parameters:
            - `get_queryname`: a callable object which returns a query name;
            - `username`: a string user name;
            - `password`: a string password (possibly, encrypted);
            - `def_enc_type`: a default encryption that shall be used if the
                              password string does not contain encryption type;
            - `try_only_once`: whether to exit on failure or retry a query;
                               defaults to True;
            - `skip_allowance_check`: whether to skip allowance check even if
                                      a 'query_allow' field is specified;
                                      defaults to False;
        :Return:
            A tuple of (success, (passed, extra)) where:
            - `success`: a boolean, did a query succeed (LDAP response received);
            - `passed`: a boolean, did an authentication passed;
            - `extra`: a dictionary containing different optional extra results;

            Currently, the following extra keys are supported:
            - `use_def_enc`: was a default encoding used for a password;
                             appears if an 'smtpauth-fetch' query was performed;
            - `emails`: a list of emails gathered from "emails_attributes";
                        only appears for 'isqauth' query;
            - `allow`: a boolean, whether SMTP AUTH is allowed.
        """
        address = sanitize_address(username)
        try:
            dummy_user = rfc_2822_parse.parse_address(address)[0]
            if not dummy_user:
                raise LDAP_Invalid_Address()
        except:
            raise LDAP_Invalid_Address()

        # Current heuristic is to attempt connectivity forever, every
        # 60 seconds.  Must apply heurstic here to allow get_queryname()
        # to return different data in the case of a config update.
        logged_errs = []
        while 1:
            queryname, query, server = self._get_query_data(get_queryname)
            extra = {}

            # Deal with meta queries
            if query['query'] == DOMAIN_BASED_LABEL:
                result =  self._domain_table_lookup(
                    'smtpauth', queryname, query, self,
                    ldap_api.query_smtpauth,
                    username, password, def_enc_type,
                    skip_allowance_check=skip_allowance_check,
                    try_only_once=try_only_once)
                if len(result) == 2:
                    return result[0], result[1], extra
                return result

            elif query['query'] == CHAINED_LABEL:
                result = self._daisy_chain_lookup(
                    'smtpauth', queryname, self, ldap_api.query_smtpauth,
                    username, password, def_enc_type,
                    skip_allowance_check=skip_allowance_check,
                    try_only_once=try_only_once)
                if len(result) == 2:
                    return result[0], result[1], extra
                return result

            # Actually, 'who' can only be 'smtpauth-fetch', 'smtpauth-bind', or
            # 'isqauth-bind' now, because "max_connections" is always set to 1
            # for 'isqauth' query type.
            who = '-'.join((query['type'], smtpauth_authtype(query)))
            if is_smtpauth_bind(query):
                success, result = self._do_smtpauth_bind(
                    query, queryname, server, address, password, who,
                    logged_errs, extra)
            else:
                success, result = self._do_smtpauth_fetch(
                    query, queryname, server, address, password, def_enc_type,
                    who, logged_errs, extra)

            if success and result and not skip_allowance_check and \
               query.get('query_allow', ''):
                success = self._query_smtpauth_allow(query, queryname,
                    server, address, who, logged_errs, extra)

            if success or try_only_once:
                return success, result, extra

            coro.sleep_relative(SERVER_DOWN_RETRY_TIME)

    def _do_smtpauth_fetch(self, query, queryname, server, address, password,
                           def_enc_type, who, logged_errs, extra):
        """
        smtpauth by fetching and comparing password.

        A "use_def_enc" key is set in the `extra` dictionary in a case of
        successful authentication.

        :Return:
            success: boolean flag
            result: boolean authentication result
        """
        ####################################################################
        # 2008-02-22 wtung:
        #
        # Notice in one case above the return value can be a 2-tuple. This is an
        # exception case. Otherwise all smtpauth_xxx methods return just a
        # boolean result. After discussion with qta we've decided this is
        # undesirable to the caller and should be reviewed.

        if def_enc_type is None:
            def_enc_type = 'plain'
        query_string, results, resolver = self._do_smtpauth_query(
            query, queryname, server, address, who, logged_errs, extra)

        # Convert raw result to ldap_entry
        success, processed_res = smtpauth_fetch_result_to_ldap_entry(results, query)
        if not success:
            self.debug_log(who, "Query %s lookup failed: %s" % (query_string, processed_res))
            return (success, processed_res)

        self.debug_log(who, "Query %s, %s returned %d results" % (query_string, resolver, len(processed_res)))

        ####################################################################
        # 2008-02-22 wtung:
        # Note that here is an inconsistence below with smtpauth-bind. For
        # smtpauth-bind, having multiple result is consider False. Here it loops
        # through each result and consider True if we found any password match.
        for entry in processed_res:
            for p in entry.userPassword:
                # "Autodetect" to see the password is an RFC 2307 type
                # of format "{hash/encryption method}password"
                m = SMTPAUTH_REGEXP.match(p)
                if m is not None:
                    g = m.groups()
                    enctype = g[0].lower()
                    ldap_pword = g[1]
                    use_default_encoding = False
                else:
                    # We are not in the format "{enctype}password" so
                    # use default encoding, and assume the retrieved
                    # password is simply in the format "password".
                    enctype = def_enc_type
                    ldap_pword = p
                    use_default_encoding = True
                if enctype == 'md5' and sslip2.FIPS_mode:
                    self.debug_log(who, 'MD5 encoded passwords are not '
                                        'supported in FIPS mode.')
                try:
                    result = passwd_validators[enctype](password, ldap_pword)
                except KeyError:
                    pass
                else:
                    extra['use_def_enc'] = use_default_encoding
                    return True, result
        # Successful inquiry, no matching results
        return (True, False)

    def _do_smtpauth_bind(self, query, queryname, server, address, password,
                          who, logged_errs, extra):
        """
        Two stage smtpauth.
        First lookup a dn. Then bind to the dn.

        :Return:
            success: boolean flag
            result: boolean authentication result
        """
        # Get the DN first
        query_string, results, resolver = self._do_smtpauth_query(
            query, queryname, server, address, who, logged_errs, extra)
        # Process raw result
        success, processed_dn_res = smtpauth_bind_dn_result_to_ldap_entry(results)
        if not success:
            self.debug_log(who, "Query %s lookup failed: %s" % (query_string, processed_dn_res))
            return (success, processed_dn_res)

        self.debug_log(who, "Query %s lookup success, %s returned %d results" % (query_string, resolver, len(processed_dn_res)))
        if (processed_dn_res is None) or (len(processed_dn_res) != 1):
            self.debug_log(who, 'first stage smtp auth failed.  query: %s results: %s' % (queryname, repr(processed_dn_res)))
            # Successful inquiry, no matching results
            return (True, False)
        self.debug_log(who, 'first stage smtp auth succeeded.  query: %s results: %s' % (queryname, repr(processed_dn_res)))

        # Update the bind server in case of referral following
        try:
            host, port = resolver[1:-1].split(':')
            if server['hostname'] != host:
                port = int(port)
                for k,v in self.servergroups.items():
                    if v['hostname'] == host and v['port'] == port:
                        server = v
                        break
                else:
                    self.debug_log(who, 'Unable to determine referral server %s - bind to original server' % (resolver,))
        except:
            self.debug_log(who, 'Unable to determine referral server %s - bind to original server' % (resolver,))

        # Now bind with the discovered DN + password
        bind_result = self._result_from_bind('smtpauth-bind', server, processed_dn_res[0], password)
        final_suc, final_result = smtpauth_bind_auth_result_to_ldap_entry(bind_result)
        if not final_suc:
            self.debug_log(who, "BIND %s returned error: %s" % (query_string, final_result))
            qlog_without_duplicates(logged_errs, 'LDAP.ERROR',
                                    queryname, final_result)
            return (False, None)
        else:
            self.debug_log(who, "BIND %s returned %s result" % (query_string, final_result))
            if not final_result:
                 self.debug_log(who, 'second stage smtp auth failed.  query: %s' % (queryname,))
            else:
                 self.debug_log(who, 'second stage smtp auth succeeded.  query: %s' % (queryname,))
            return (True, final_result)

    def _do_smtpauth_query(self, query, queryname, server, address, who,
                           logged_errs, extra):
        """
        Run query to look up LDAP record for 'address'.

        :Return:
            - query_string: ldap query string used
            - results: see _result_from_query()
            - resolver: see _result_from_query()
        """

        look_for_attrs = []
        userpassword_value = query.get("userpassword",None)
        if userpassword_value:
            # Include additional "smtpauth" attributes
            look_for_attrs = [userpassword_value]

        email_attrs = []
        email_attributes_value = query.get("email_attributes",None)
        if email_attributes_value:
            email_attrs = email_attributes_value.lower().split(',')
            look_for_attrs.extend(email_attrs)

        query_string = self._do_substitution(query['query'], address, None, None)
        results, resolver = self._result_from_query(query_string, queryname,
                                          server, look_for_attrs,
                                          who, logged_errs,
                                          query_syntax_error='LDAP.INFO')

        # collect email address for attributes defined in email_attributes
        if email_attrs:
            _emails = []
            success, result = results
            if success and result:
                dn, raw_attrs = result[0]
                # Turn all attribute names to lowercase
                attrs = dict((k.lower(), v) for k,v in raw_attrs.items())

                # bug fix 21947
                if attrs.has_key('userpassword'):
                    attrs['userpassword'] = '****'

                invalid_email_attrs = []
                valid_email_attrs = []
                for key in email_attrs:
                    if key in attrs:
                        _emails.extend(attrs[key])
                        valid_email_attrs.append(key)
                    else:
                        invalid_email_attrs.append(key)

                # We need to check valid email entries in `email` list
                # and remove duplicates,  keeping the original sequence of emails
                # and in the original case.
                extra['emails'] = filter_email_list(_emails, server['server_type'])

                if invalid_email_attrs:
                    invalid_email_attrs_str = ', '.join(invalid_email_attrs)
                    self.debug_log(who, '***WARNING***: email_attributes [%s] are not defined in result' % invalid_email_attrs_str)
                if valid_email_attrs:
                    valid_email_attrs_str = ', '.join(valid_email_attrs)
                    emails_str = ', '.join(extra['emails'])
                    self.debug_log(who, 'email_attributes: [%s] emails: %s' % (valid_email_attrs_str , emails_str))

        return query_string, results, resolver

    def _query_smtpauth_allow(self, query, queryname, server, address, who,
                              logged_errs, extra):
        """Run LDAP query stored in query['query_allow'] to check if SMTP AUTH
        is allowed for user.

        :Return:
            A boolean flag which indicates whether a call to LDAP server
            succeed.  If LDAP query succeed then the `extra['allow']` is
            set to a boolean flag which indicates whether user is allowed
            to do SMTP AUTH.
        """
        query_string = self._do_substitution(query['query_allow'], address,
                                             None, None)
        results, resolver = self._result_from_query(query_string, queryname,
            server, [], who, logged_errs, query_syntax_error='LDAP.INFO')

        # Process results
        server_up, server_result = results
        if server_up:
            self.debug_log(who, 'Allowance query %s lookup success, %s '
                'returned %s results' % (query_string, resolver,
                                         len(server_result)))
            extra['allow'] = True if server_result else False
        else:
            self.debug_log(who, 'Allowance query %s lookup failed: %s' %
                                    (query_string, server_result))
            qlog_without_duplicates(logged_errs, 'LDAP.ERROR', queryname,
                                    server_result)

        return server_up

    def query_isqauth(self, get_queryname, username, password, def_enc_type, try_only_once=True):
        return self.query_smtpauth(get_queryname, username, password, def_enc_type, try_only_once)

    def query_certauth(self, get_queryname, certificate, try_only_once=True):
        """Certificate Authentication Query where `certificate` can be
        `sslip.x509` instance or dictionary.

        :Return:
            (`success`, `result`): where a `success` contains a boolean flag
            whether call to LDAP server succeed, a `result` is a string user ID
            if matching record was found or empty string otherwise.
        """

        queryname, query, server = self._get_query_data(get_queryname)

        if 'uid' not in query or 'auth_fields' not in query:
            raise LDAP_Noop

        if isinstance(certificate, dict):
            # dict type is supported for ldaptest.
            subs = certificate
        else: #if isinstance(certificate, sslip.x509):
            # x509 is not a part of sslip public interface
            subs = {}

            for field in query['auth_fields']:
                if field == 'sn':
                    subs[field] = certificate.get_serial_number()
                else:
                    subs[field] = certificate.get_subject(
                        certificate_subject_fields_map[field])

        logged_errs = []
        while 1:
            query_string = self._do_substitution(query['query'], None,
                None, None, custom_substs=subs)
            (success, raw_results), resolver = self._result_from_query(query_string,
                queryname, server, [query['uid'], ], query['type'],
                logged_errs, query_syntax_error='LDAP.INFO')

            result = ''
            if success:
                self.debug_log('certauth',
                    'Query %s lookup success, %s returned %d results: %r' %
                    (query_string, resolver, len(raw_results), raw_results))

                # In order to be consistent with the SMTP AUTH with BIND treat
                # certificate authentication as successful only if exactly one
                # record was found - multiple records are treated as a failure.
                # Absense of an uid attribute is also treated as a failure.
                if len(raw_results) == 1:
                    # Bug 88767
                    # raw_results is the server`s response to the query we sent.
                    # It contains all the attributes in lower case (default).
                    # To authenticate raw_result with the user specified attribute,
                    # convert the attribute into the default lower case.
                    uid = raw_results[0][1].get(query['uid'].lower(), [])
                    if len(uid) == 1:
                        result = uid[0]
            else:
                self.debug_log('certauth', 'certauth %s returned error: %s' %
                                           (query_string, raw_results))
                qlog_without_duplicates(logged_errs, 'LDAP.ERROR', queryname,
                                        raw_results)

            if success or try_only_once:
                return (success, result)

            coro.sleep_relative(SERVER_DOWN_RETRY_TIME)

    def _get_query_data(self, get_queryname):
        """_get_query_data()
        Helper routine to extract useful bits from a supplied callback."""
        queryname = get_queryname()[0]
        if queryname is None:
            raise LDAP_Noop

        try:
            query = self.queries[queryname]
        except KeyError:
            qlog.write('LDAP.NONEXISTENT_QUERY', repr(queryname))
            raise LDAP_Noop

        if query['query'] not in [DOMAIN_BASED_LABEL, CHAINED_LABEL]:
            try:
                server = self.servergroups[query['server']]
            except KeyError:
                qlog.write('LDAP.ERROR', queryname, "LDAP SERVER doesn't exist, aborting.")
                raise LDAP_Noop
        else:
            server = 'unused'

        return (queryname, query, server)

    def _queryname_to_data(self, queryname):
        """_queryname_to_data()
        Helper routine to extract useful bits from a supplied query name."""
        try:
            query = self.queries[queryname]
        except KeyError:
            qlog.write('LDAP.NONEXISTENT_QUERY', repr(queryname))
            raise LDAP_Noop

        if query['query'] not in [DOMAIN_BASED_LABEL, CHAINED_LABEL]:
            try:
                server = self.servergroups[query['server']]
            except KeyError:
                qlog.write('LDAP.ERROR', queryname, "LDAP SERVER doesn't exist, aborting.")
                raise LDAP_Noop
        else:
            server = 'unused'

        return (queryname, query, server)

    def _format_generalized_time(self, tsc):
        """Convert `aplib.tsc_time.Time` date and time to generalized time
        string.
        """
        return tsc.mkstr_utc('%Y%m%d%H%M%SZ')

    def _do_substitution(self, query, address, group_name, mail_from,
                         custom_substs=None):
        user = None
        domain = None
        generalized_time = self._format_generalized_time(tsc_time.now_tsc())
        if address is not None:
            assert isinstance(address, str)
            user, domain = ironutil.addr_split(address)
            # apply rfc2254 quoting rules
            user = ldap.query_escape(user)
            domain = ldap.query_escape(domain)
            address = ldap.query_escape(address)
            if group_name is not None:
                group_name = ldap.query_escape(group_name)
            if mail_from is not None:
                mail_from = ldap.query_escape(mail_from)

        subs = {'a': address,
                'u': user,
                'd': domain,
                'g': group_name,
                'f': mail_from,
                't': generalized_time,
               }

        if custom_substs:
            subs.update(custom_substs)

        formatter = CaseInsensitiveFormatter()

        try:
            return formatter.format(query, **subs)
        except KeyError, e:
            qlog.write('LDAP.ERROR', query, 'Query substitution failed. '
                                            'Field not found %s' % (e, ))
            raise LDAP_Noop
        except ValueError, e:
            qlog.write('LDAP.ERROR', query, 'Query substitution failed. '
                                            'Field is not supported.')
            raise LDAP_Noop

    def _domain_table_lookup(self, log_type, query_name, query_object,
                             ldap_api_object, query_func, *args, **kwargs):
        """_domain_table_lookup()
        Generic domain-based lookup code.  Callers supply arguments
        and a callback.

        <log_type>      string of "route", "accept", etc
        <query_name>    name of query
        <query_object>  ldap_api instantiation
        <query_func>    callback to perform query
        <query_args>    args to supply to query function
        """
        self.debug_log(log_type, "Executing domain-based query %s" % (query_name,))

        # Grab table from self.meta_query_cache
        lookup_tables = self.meta_query_cache.get(query_object['name'], None)
        if lookup_tables is None:
            qlog.write('LDAP.ERROR', query_name, "LDAP domain-based QUERY doesn't exist, aborting.")
            raise LDAP_Noop

        # Discover which address should be used for lookup
        lookup_address = address_from_query_type(query_object, *args)

        # Try to find a table entry for "lookup_address"
        new_queryname = address_to_domain_table_entry(lookup_address, lookup_tables,
                                                      query_object.get('defaultdomain', None))

        # No table entry found, return "no hit" response.  This means
        # the address fell off the end of the table, which should be
        # interpretted as "successful lookup attempt, no match".
        if new_queryname is None:
            self.debug_log(log_type, "Query %s domain table failed to match %s" % (query_name, lookup_address))
            return (True, [])

        return query_func(ldap_api_object, lambda x=new_queryname: (x, 1, x), *args, **kwargs)

    def _daisy_chain_lookup(self, log_type, query_name, query_object,
                            query_func, *args, **kwargs):
        """_daisy_chain_lookup()
        Generic daisy-chain following code.  Callers supply arguments
        and a callback.

        <log_type>      string of "route", "accept", etc
        <query_name>    name of query
        <query_object>  ldap_api instantiation
        <query_func>    callback to perform query
        <query_args>    args to supply to query function
        """
        self.debug_log(log_type, "Executing chained query %s" % (query_name,))

        # Grab chain from self.meta_query_cache
        query_chain = self.meta_query_cache.get(query_name, None)
        if query_chain is None:
            qlog.write('LDAP.ERROR', query_name, "LDAP chained QUERY doesn't exist, aborting.")
            raise LDAP_Noop

        dc_success = True
        dc_result = []
        result = (dc_success, dc_result)

        # Walk chain of queries to attempt
        for link in query_chain:
            result = query_func(query_object,
                                lambda x=link: (x, 1, x),
                                *args, **kwargs)
            dc_success, dc_result = result[:2]

            # Server failures are really bad
            if not dc_success:
                continue

            # Make sure we're successful *and* we have a valid result
            result_success = True if dc_result else False
            try:
                for res in dc_result:
                    if isinstance(res, ldap_entry):
                        result_success = result_success and not res.is_empty()
                    else:
                        break
            except TypeError:
                pass
            if result_success:
                return result
        else:
            if not dc_success:
                return (False,
                    "Chained query %s failed: server failure with query %s" \
                    % (query_name, link))

        # Return last results, similar if not exactly (True, [])
        return result

    def query_extauth_bind(self, get_queryname, username, password,
                           try_only_once=True):
        """Bind to a LDAP server as user.

        :Parameters:
            - `get_queryname`: callable object which returns query name.
            - `username`: a string of format username[@domain].
            - `password`: user password.
            - `try_only_once`: if True the result (whatever success or
              failure) will be returned immediately,
              otherwise the query will retry until success.

        :Return:
            Tuple of (server_up, result), where server_up is boolean
            indicating if server is up.  result is True if bound
            successfully, otherwise False.
        """

        logged_errs = []
        while 1:
            queryname, query, server = self._get_query_data(get_queryname)

            # Deal with meta queries
            if query['query'] == DOMAIN_BASED_LABEL:
                return self._domain_table_lookup('extauth-bind', queryname,
                    query, self, ldap_api.query_extauth_bind, username,
                    password, try_only_once=try_only_once)

            elif query['query'] == CHAINED_LABEL:
                return self._daisy_chain_lookup('extauth-bind', queryname,
                    self, ldap_api.query_extauth_bind, username, password,
                    try_only_once=try_only_once)

            username, domain = ironutil.addr_split(username)

            success, user_dn = self._extauth_get_user_dn(get_queryname,
                username, logged_errs=logged_errs)
            if not success:
                if try_only_once:
                    return (False, False)

            else:
                if user_dn is None:
                    return (True, False)

                # Now bind with the discovered DN + password
                final_suc, final_result = self._result_from_bind(
                    'extauth-bind',server, user_dn, password)
                if not final_suc:
                    self.debug_log('extauth-bind',
                        "BIND %s returned error: %s" % (user_dn,
                        final_result))
                    qlog_without_duplicates(logged_errs, 'LDAP.ERROR',
                        queryname, final_result)
                    if try_only_once:
                        return (False, False)
                else:
                    self.debug_log('extauth-bind',
                        "BIND %s returned %s result" % (user_dn,
                        final_result))
                    if not final_result:
                        self.debug_log('extauth-bind',
                        'authentication failed.  query: %s' % (queryname,))
                    self.debug_log('extauth-bind',
                        'authentication succeeded.  query: %s' % (queryname,))
                    return (True, final_result)

            coro.sleep_relative(SERVER_DOWN_RETRY_TIME)

    def query_extauth_get_user_entry(self, get_queryname, username,
                                       look_for_attrs=None, domain=None,
                                       try_only_once=True,
                                       literal_attrs=None):
        """Return LDAP entries of users.

        If specified query is domain-based than the result will be
        the union of all sub-query results.

        :Parameters:
            - `get_queryname`: callable object which returns query name.
            - `username`: user name to look up.
            - `look_for_attrs`: list of generic attribute names.  If it
              is None the whole LDAP entry is returned. Generic attributes
              will be resolved individually for each query depending on
              schema settings. Can be one of attribute keys of the external
              authentication query without the "_attribute" suffix,
              ex. "login", "group_name", or "member".
            - `domain`: a domain the query is associated with.  Is used for
              post-processing query results.
            - `try_only_once`: if True the result (whatever success or
              failure) will be returned immediately, otherwise the query
              will retry until success.
            - `literal_attrs`: attributes to request without any translation
              from our "simplified" attribute names.

        :Return:
            A tuple (server_up, user_entry), where server_up is a boolean
            indicating if server is up and user_entry is a dictionary of
            of the structure the _extauth_convert_user_entry() returns or None
            if user does not exist.
        """

        logged_errs = []
        while 1:
            queryname, query, server = self._get_query_data(get_queryname)

            # Deal with meta queries
            if query['query'] == DOMAIN_BASED_LABEL:
                return self._domain_table_lookup('extauth-getusers', queryname,
                    query, self, ldap_api.query_extauth_get_user_entry,
                    username, look_for_attrs=look_for_attrs,
                    domain=domain, try_only_once=try_only_once)

            elif query['query'] == CHAINED_LABEL:
                return self._daisy_chain_lookup('extauth-getusers', queryname,
                    self, ldap_api.query_extauth_get_user_entry, username,
                    look_for_attrs=look_for_attrs, domain=domain,
                    try_only_once=try_only_once)

            base_dn = query['account_base']
            username = ironutil.addr_split(username)[0]
            query_string = query['user_query'].replace("{u}",
                ldap.query_escape(username))

            look_for_attrs = self._extauth_translate_attrs(query,
                look_for_attrs)
            if literal_attrs:
                for literal_attr in literal_attrs:
                    if literal_attr not in look_for_attrs:
                        look_for_attrs.append(literal_attr)

            (success, raw_results), resolver = self._result_from_query(
                query_string, queryname, server, look_for_attrs,
                'extauth-getusers', logged_errs,
                query_syntax_error='LDAP.INFO', base_dn=base_dn)

            if not success:
                self.debug_log('extauth-getusers',
                    "Query %s lookup failed: %s" % (query_string, raw_results))
                if try_only_once:
                    return (False, None)

            else:
                if len(raw_results) != 1:
                    self.debug_log('extauth-getusers',
                        'Failed to obtain user entry. query: %s results: %s' %
                        (queryname, repr(raw_results)))
                    return (True, None)

                self.debug_log('extauth-getusers',
                    "Query %s lookup success, %s returned %d results" %
                    (query_string, resolver, len(raw_results)))

                user_dn, attr_dict = raw_results[0]
                result = self._extauth_convert_user_entry(query, attr_dict,
                        domain)
                result['dn'] = user_dn

                return (True, result)

            coro.sleep_relative(SERVER_DOWN_RETRY_TIME)

    def query_extauth_get_user_group_names(self, get_queryname, username,
                                           look_for_groups=None,
                                           try_only_once=True,
                                           user_to_dn_map={}):
        """Return a list of group names the user is member of.

        :Parameters:
            - `get_queryname`: callable object which returns query name.
            - `username`: a user name.
            - `look_for_groups`: a list of group names to look for.  If it is
              None or empty all groups will be searched.
            - `try_only_once`: if True the result (whatever success or
              failure) will be returned immediately, otherwise the query
              will retry until success.
            - `user_to_dn_map`: Map of usernames to DNs (for {dn} substitution)

        :Return:
            A tuple (server_up, result_list), where server_up is boolean
            indicating if server is up and result_list a list of group
            names or None if user does not exist.
        """

        logged_errs = []
        while 1:
            queryname, query, server = self._get_query_data(get_queryname)

            # Deal with meta queries
            if query['query'] == DOMAIN_BASED_LABEL:
                return self._domain_table_lookup('extauth-getusergroups',
                    queryname, query, self,
                    ldap_api.query_extauth_get_user_group_names, username,
                    look_for_groups=look_for_groups,
                    try_only_once=try_only_once,
                    user_to_dn_map=user_to_dn_map)

            elif query['query'] == CHAINED_LABEL:
                return self._daisy_chain_lookup('extauth-getusergroups',
                    queryname, self,
                    ldap_api.query_extauth_get_user_group_names, username,
                    look_for_groups=look_for_groups,
                    try_only_once=try_only_once,
                    user_to_dn_map=user_to_dn_map)

            username = ironutil.addr_split(username)[0]
            server_type = server.get('server_type', '')
            base_dn = query['group_base']
            group_name_attr = query['group_name_attribute']
            group_filter = ''
            if look_for_groups:
                group_filter_parts = []
                for group_name in look_for_groups:
                    group_filter_parts.append('(%s=%s)' % (group_name_attr,
                        ldap.query_escape(group_name),))

                group_filter = '(|%s)' % (''.join(group_filter_parts), )

            if server_type == 'ad':
                # AD stores DNs in member attribute
                success, member_attribute_value = \
                    self._extauth_get_user_dn(get_queryname,
                        username, logged_errs=logged_errs)
            else:
                member_attribute_value = username
                success = True

            if not success:
                if try_only_once:
                    return (False, None)
            else:
                if member_attribute_value is None:
                    return (True, None)

                membership_query = query['membership_query'].replace(
                    "{u}", ldap.query_escape(member_attribute_value))
                # This is specialy handling for SunOne, and other LDAP servers
                # that store members as DNs instead of simple usernames.  In
                # this case, we attempt to resolve the DN to a user that has
                # been "seen" before (i.e., for which the user record has
                # been retrieved).
                if membership_query.find('{dn}') > -1:
                    if user_to_dn_map.has_key(username):
                        membership_query = membership_query.replace(
                            "{dn}", ldap.query_escape(user_to_dn_map[username])
                        )
                    else:
                        # Don't attempt to create a query with {dn} still
                        # in place -- it will never match anything.  Just
                        # return an empty result.
                        return (False, None)
                if group_filter:
                    query_string = '(&%s%s)' % (membership_query, group_filter)
                else:
                    query_string = membership_query

                (success, raw_results), resolver = self._result_from_query(
                    query_string, queryname, server, [group_name_attr],
                    'extauth-getusergroups', logged_errs,
                    query_syntax_error='LDAP.INFO', base_dn=base_dn)

                if not success:
                    self.debug_log('extauth-getusergroups',
                        "Query %s lookup failed: %s" % (query_string,
                        raw_results))
                    if try_only_once:
                        return (False, None)

                else:
                    self.debug_log('extauth-getusergroups',
                        "Query %s lookup success, %s returned %d results" %
                        (query_string, resolver, len(raw_results)))

                    result = []
                    for group_dn, attr_dict in raw_results:
                        group_name = attr_dict.get(group_name_attr)
                        if group_name is not None:
                            if isinstance(group_name, list):
                                group_name = group_name[0]
                            result.append(group_name)

                    return (True, result)

            coro.sleep_relative(SERVER_DOWN_RETRY_TIME)

    def _extauth_translate_attrs(self, query, look_for_attrs):
        """Translate generic attribute names to LDAP schema-specific ones.

        Generic (schema-independent) attributes are keys of dictionaries
        which are used outside of this API, i.e login, group_name, etc.

        :Parameters:
            - `query`: dictionary containing LDAP query params.
            - `look_for_attrs`: list of generic attributes.

        :Return:
            A list of LDAP entry attributes or None if look_for_attrs is none.
        """

        if look_for_attrs is None:
            return None

        result = []
        for name in look_for_attrs:
            attr = "%s_attribute" % (name,)
            if query.has_key(attr):
                result.append(query[attr])

        return result

    def _extauth_convert_user_entry(self, query, attr_dict, domain=None):
        """Convert actual LDAP attributes returned by LDAP
        to generic attributes. Attribute values are not changed.

        Keys of attr_dict are attributes returned by LDAP server.
        On output, the same dictionary is returned with keys replaced with
        those generic, for example "samAccountName" will be chagned
        to "login", "cn" to "group_name", etc.

        :Parameters:
            - `query`: a dictioanry of query parameters.
            - `attr_dict`: a dictionary of data returned from LDAP.
            - `domain`: domain to append to username.

        :Return:
            A dictionary of format described above.  If some keys do not
            exist in `attr_dict` corresponding keys will not show up in
            a resulting dictionary.
        """
        result_dict = {}

        def process_value(generic_key, ldap_key, as_int=False):
            value = attr_dict.get(ldap_key)
            if isinstance(value, list):
                if value:
                    value = value[0]
                    if as_int:
                        try:
                            value = int(value)
                        except ValueError:
                            value = None
                else:
                    value = None

            if value is not None:
                result_dict[generic_key] = value

        # Attributes that must be preserved intact (don't prune extra values)
        if attr_dict.has_key('memberOf'):
            result_dict['memberOf'] = attr_dict['memberOf']

        for name in (typevars['externalauth']):
            # Group attributes should not be processed here.
            if not name.startswith('group'):
                process_value(name.replace("_attribute", ""), query.get(name))

        if result_dict.has_key('login') and domain is not None:
            result_dict['login'] = '%s@%s' % (result_dict['login'], domain)

        return result_dict

    def _extauth_get_user_dn(self, get_queryname, username,
            logged_errs=None):
        """Return DN of the user.

        :Parameters:
            - `get_queryname`: callable object which returns query name.
            - `username`: a user name.
            - `logged_errs`: list of qlog codes of messges which have been
              logged already.

        :Return:
            A tuple (server_up, user_dn), where server_up is boolean
            indicating if server is up and user_dn is a string containing
            user DN or None if user does not exist.
        """

        if logged_errs is None:
            logged_errs = []

        queryname, query, server = self._get_query_data(get_queryname)

        base_dn = query['account_base']
        query_string = query['user_query'].replace("{u}",
            ldap.query_escape(username))

        look_for_attrs = []
        results, resolver = self._result_from_query(query_string,
            queryname, server, look_for_attrs, 'extauth-getuserdn',
            logged_errs, query_syntax_error='LDAP.INFO', base_dn=base_dn)

        success, raw_results = results
        if not success:
            self.debug_log('extauth-getuserdn', "Query %s lookup failed: %r"
                % (query_string, raw_results))

            return (False, None)
        else:
            dn_list = [dn for dn, attrs in raw_results]
            self.debug_log('extauth-getuserdn',
                "Query %s lookup success, %s returned %d results" %
                (query_string, resolver, len(dn_list)))

            if len(dn_list) != 1:
                self.debug_log('extauth-getuserdn',
                    'Failed to discover user DN.  query: %s results: %s' %
                    (queryname, repr(dn_list)))
                return (True, None)

            user_dn = dn_list[0]

            return (True, user_dn)


# "the_ldap_api" runtime object initialization
the_ldap_api = ldap_api()

def initialize(maximum_connections = 0):
    global the_ldap_api
    global servers, queries
    global ldap_thread, ldap_thread_started

    initialize_ssl_ctx()

    the_ldap_api.initialize()
    the_ldap_api.update_local_interface(interface)
    the_ldap_api.refresh_servergroups(servers, maximum_connections)
    the_ldap_api.refresh_queries(queries)

    # Start the config management thread if we created one and
    # not started yet.
    if ldap_thread and not ldap_thread_started:
        ldap_thread_started = True
        ldap_thread.start()

    certconfig.init()
    update_cert_key()
    certconfig.subscribe_to_config_change(certconfig_changed)

def register_config(maximum_connections = 0):
    """ Creates the config_threads to handle config changes
    """
    global config_change_queue
    global ldap_thread
    if not ldap_thread:
        ldap_thread = coro.new (ldap_manager,
                                maximum_connections=maximum_connections)
        ldap_thread.set_name('ldap_manager')
        config_change_queue = CommandManager.register('hermes.ldap',
                                                      sys.modules[__name__],
                                                      ldap_thread)
        CommandManager.register('system.network', None,
                                ldap_thread,
                                change_queue=config_change_queue)
    certconfig.register_config()

# config_change_queue & manager thread
ldap_thread = None
ldap_thread_started = False
config_change_queue = None

def ldap_manager(maximum_connections = 0):
    global the_ldap_api, config_change_queue
    global servers, queries

    while 1:
        old_vars = config_change_queue.dequeue()

        reinit_server_groups = False
        refresh_servers = False
        clobber_cache = False
        refresh_the_queries = False

        # old_vars contains a list of which values changed
        if old_vars.has_key('servers'):
            refresh_servers = True
            clobber_cache = True

        if old_vars.has_key('queries'):
            the_ldap_api.queries = queries
            refresh_the_queries = True
            clobber_cache = True

        if old_vars.has_key('interface'):
            the_ldap_api.update_local_interface(interface)
            reinit_server_groups = True

        if old_vars.has_key('interfaces'): # i.e. system.network.interfaces
            reinit_server_groups = True
            the_ldap_api.update_local_interface(interface)

        if old_vars.has_key('ssl_certid'):
            update_cert_key()
            # Force re-initialization of servergroups if certificate changes
            reinit_server_groups = True

        # Process the "what has changed" flags
        if reinit_server_groups:
            the_ldap_api.refresh_servergroups({}, maximum_connections)

        if refresh_servers or reinit_server_groups:
            the_ldap_api.refresh_servergroups(servers, maximum_connections)

        if refresh_the_queries:
            the_ldap_api.refresh_queries(queries)

        if clobber_cache:
            the_ldap_api.clear_cache()

def initialize_ssl_ctx():
    global ssl_ctx

    if not ssl_ctx:
        ssl_ctx = coro_ssl.new_ssl_ctx()
    enable_SSLv3 = quick_read_var_auto_level('hermes.ldap.sslv3enabled')
    # Explicitly turned off or off by default
    if not enable_SSLv3 or enable_SSLv3 == NOTSET:
        qlog.write('LDAP.DEBUG', 'SSLv3 disabled')
        ssl_ctx.set_options(sslip2.SSL_OP.NO_SSLv3)
    else:
        ssl_options = ssl_ctx.get_options()
        # On the off chance that the current context has had SSLv3 turned off,
        # turn it back on
        if ssl_options & sslip2.SSL_OP.NO_SSLv3:
            ssl_ctx.clear_options(sslip2.SSL_OP.NO_SSLv3)
            qlog.write('LDAP.DEBUG', 'SSLv3 re-enabled')
        else:
            qlog.write('LDAP.DEBUG', 'SSLv3 enabled')

# SSL cert handling
def update_cert_key():
    # Import certs here to avoid circular dependency
    global ssl_ctx
    import certs
    initialize_ssl_ctx()
    ssl_ctx = coro_ssl.new_ssl_ctx()
    cp = certs.certificate_manager.get(ssl_certid, certs.default_cert)
    cp.update_context(ssl_ctx)

def certconfig_changed(oldvars):
    # Any of these changes forces a reload of the CA bundle (certstore)
    update_cert_key()

# Remote cmds
def remote_cmd_commit(option):
    pass

def remote_cmd_clear_caches(option):
    """remote_cmd_clear_caches(option)

    If option is None, clear all caches.

    To be more selective, option can be a tuple of (queryname,
    address, group_or_envelope_sender).
    """
    if not option:
        the_ldap_api.clear_cache()
    else:
        queryname, address, group_or_envelope_sender = option
        query_string = queries.get(queryname, None)
        if not query_string:
            qlog.write('LDAP.DEBUG', "clear_caches: query not found %s" % (queryname,))
            return

        query_string = the_ldap_api._do_substitution(query_string['query'], address, None,
                                                     group_or_envelope_sender)

        for key in the_ldap_api.servergroups.keys():
            sg = the_ldap_api.ldap_client.get_server_group(key)
            if sg is None:
                pass
            else:
                sg.clear_cache_entry(query_string)

def wait_for_server(my_ldap_api, server, timeout=60):
    """wait_for_server_group(my_ldap_api, server, timeout)

    Wait for the server group to complete its network initialization

    Return True if the server is ready before timeout, False otherwise.
    """
    sg = my_ldap_api.ldap_client.get_server_group(server)
    if not sg:
        return False
    for x in xrange(timeout):
        if sg.is_ready():
            return True
        if sg.check_auth_failure():
            if my_ldap_api.status_msg is not None:
                my_ldap_api.status_msg.append('Authentication failed.')
            return False
        coro.sleep_relative(1)
    if my_ldap_api.status_msg is not None:
        my_ldap_api.status_msg.append('Connection Error: The server is not responding.')
    return False

def get_address_query(attrs, email, server_type):
    query = '(|'
    if server_type == 'ad':
        format_str = "(%(attr)s=%(email)s)(%(attr)s=smtp:%(email)s)"
    else:
        format_str = "(%(attr)s=%(email)s)"
    d = {'email': email}
    for attr in attrs:
        d['attr'] = attr
        query += format_str % d
    query += ')'
    return query

def filter_email_list(emails, server_type):
    """Remove duplicates and whatever is not a valid e-mail address.
    Strip "smtp:" prefix for ActiveDirectory.

    :Parameters:
        - `emails`: List of strings returned from LDAP query as values of
          email attributes.
        - `server_type`: Type of the LDAP server.

    :Return:
        List of valid unique email addresses.
    """
    valid_emails = []
    # Check for uniqueness, do not use valid_emails because
    # of character case issue.
    seen = set()
    for email in emails:
        email_lower = email.lower()
        if server_type == 'ad' and email_lower.startswith('smtp:'):
            email = email[5:]
            email_lower = email_lower[5:]
        if email_lower not in seen:
            if rfc_2821_parse.strict_re.make().strict_mailbox_re.match(email):
               # Add valid email address to the list.
               valid_emails.append(email)
               seen.add(email_lower)
    return valid_emails

def get_query_server_name(query_name, queries):
    """Retrieve the server name associated with the given query.  For
    meta query, retrieve the server name associated with the first
    non-meta query.
    :Parameters:
        - 'query_name': the name of the query
        - 'queries': query map
    :Returns:
        - server name of the first non-meta query, or None
    """
    query_names = set()
    def iter(query_name, qlist):
        if query_name is None:
            if qlist:
                return iter(qlist[0], qlist[1:])
            else:
                return None

        # keep track of query encountered
        if query_name in query_names:
            return iter(None, qlist)
        else:
            query_names.add(query_name)

        query = queries.get(query_name)
        if not query:
            return iter(None, qlist)

        # search for the first server breath-first recursively
        server = query.get('server')
        if not server:
            if query['query'] == CHAINED_LABEL:
                qlist.extend(query.get('chainlist', []))
            elif query['query'] == DOMAIN_BASED_LABEL:
                qlist.extend(query.get('domainmap', {}).values())
            return iter(None, qlist)
        else:
            return server

    return iter(query_name, [])

# Helper Functions

class CaseInsensitiveFormatter(string.Formatter):

    """Provides the string.format functionality while ignoring the case of
    replacement field.
    """

    def get_field(self, field_name, args, kwargs):
        field_args = {}
        for k, v in kwargs.iteritems():
            if isinstance(k, basestring):
                field_args[k.lower()] = v
            else:
                field_args[k] = v

        if isinstance(field_name, basestring):
            name = field_name.lower()
        else:
            name = field_name

        return super(CaseInsensitiveFormatter, self).get_field(name, args,
                                                               field_args)

if __name__ == '__main__':
    import backdoor

    coro.spawn (backdoor.serve)

    def t1():
        e = query('inbound', 'jmontrose@ironport.com')
        print "local",e.localAddress
        print "route",e.routingAddress
        return e

    coro.event_loop (30.0)
